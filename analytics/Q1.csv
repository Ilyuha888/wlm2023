"Timestamp","Total score","Имя Фамилия","Имя Фамилия [Score]","Имя Фамилия [Feedback]","К основным типам данных языка R относятся","К основным типам данных языка R относятся [Score]","К основным типам данных языка R относятся [Feedback]","Синонимом к типу данных «logical» является тип","Синонимом к типу данных «logical» является тип [Score]","Синонимом к типу данных «logical» является тип [Feedback]","Числовыми типами данных языка R являются:","Числовыми типами данных языка R являются: [Score]","Числовыми типами данных языка R являются: [Feedback]","Литерал NULL используется","Литерал NULL используется [Score]","Литерал NULL используется [Feedback]","Функция class() при выполнении на объектах
17, 'e' и ""True"" 
вернет соответственно","Функция class() при выполнении на объектах
17, 'e' и ""True"" 
вернет соответственно [Score]","Функция class() при выполнении на объектах
17, 'e' и ""True"" 
вернет соответственно [Feedback]","Выполнение команды 
c(6, FALSE, c(TRUE, ""match"")) 
приведет к результату","Выполнение команды 
c(6, FALSE, c(TRUE, ""match"")) 
приведет к результату [Score]","Выполнение команды 
c(6, FALSE, c(TRUE, ""match"")) 
приведет к результату [Feedback]","Выполнение команды 
c(c(TRUE, 12.5, TRUE), c(""wow"", FALSE))
приведет к результату","Выполнение команды 
c(c(TRUE, 12.5, TRUE), c(""wow"", FALSE))
приведет к результату [Score]","Выполнение команды 
c(c(TRUE, 12.5, TRUE), c(""wow"", FALSE))
приведет к результату [Feedback]","Если мы будем вручную приводить вектор
с(FALSE, ""2"", ""s"") 
к числовому типу данных, мы получим","Если мы будем вручную приводить вектор
с(FALSE, ""2"", ""s"") 
к числовому типу данных, мы получим [Score]","Если мы будем вручную приводить вектор
с(FALSE, ""2"", ""s"") 
к числовому типу данных, мы получим [Feedback]","Объектом в R может быть","Объектом в R может быть [Score]","Объектом в R может быть [Feedback]","Структурой данных языка R не является","Структурой данных языка R не является [Score]","Структурой данных языка R не является [Feedback]","Датафрейм наследует свойства","Датафрейм наследует свойства [Score]","Датафрейм наследует свойства [Feedback]","При индексации матрицы возможно выделить из неё","При индексации матрицы возможно выделить из неё [Score]","При индексации матрицы возможно выделить из неё [Feedback]","Для индексации списков в R используется следующий вид скобок:","Для индексации списков в R используется следующий вид скобок: [Score]","Для индексации списков в R используется следующий вид скобок: [Feedback]","Верно, что","Верно, что [Score]","Верно, что [Feedback]","Верно, что","Верно, что [Score]","Верно, что [Feedback]","Соотнесите вариант индексации списка и результат выполнения команды [1]","Соотнесите вариант индексации списка и результат выполнения команды [1] [Score]","Соотнесите вариант индексации списка и результат выполнения команды [2]","Соотнесите вариант индексации списка и результат выполнения команды [2] [Score]","Соотнесите вариант индексации списка и результат выполнения команды [3]","Соотнесите вариант индексации списка и результат выполнения команды [3] [Score]","Соотнесите вариант индексации списка и результат выполнения команды [4]","Соотнесите вариант индексации списка и результат выполнения команды [4] [Score]","В каком примере кода нет ошибки в синтаксисе условного оператора?","В каком примере кода нет ошибки в синтаксисе условного оператора? [Score]","В каком примере кода нет ошибки в синтаксисе условного оператора? [Feedback]","Если в теле функции отсутствует return(), то она","Если в теле функции отсутствует return(), то она [Score]","Если в теле функции отсутствует return(), то она [Feedback]","Если функция принимает несколько аргументов, то их необходимо ей передавать","Если функция принимает несколько аргументов, то их необходимо ей передавать [Score]","Если функция принимает несколько аргументов, то их необходимо ей передавать [Feedback]","Соотнесите элемент функции с его задачей [название объекта, в котором хранится функция]","Соотнесите элемент функции с его задачей [название объекта, в котором хранится функция] [Score]","Соотнесите элемент функции с его задачей [описание алгоритма работы функции]","Соотнесите элемент функции с его задачей [описание алгоритма работы функции] [Score]","Соотнесите элемент функции с его задачей [определение объекта, который возвращает функция]","Соотнесите элемент функции с его задачей [определение объекта, который возвращает функция] [Score]","Соотнесите элемент функции с его задачей [задание входных объектов функции]","Соотнесите элемент функции с его задачей [задание входных объектов функции] [Score]"
"2023/10/07 4:31:25 PM GMT+3","22.00 / 26","","","","num, int, char, bool","0.00 / 1","Не совсем...
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;датафрейм;функция;список","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;целую строку;целый столбец","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;массивы объединяют объекты разных типов данных","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/07 9:03:22 PM GMT+3","18.00 / 26","","","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""0""    ""TRUE""    ""match""","0.00 / 1","Следите за руками!
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;список;датафрейм","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец;один элемент в конкретных столбце и строке","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/08 6:41:06 PM GMT+3","21.00 / 26","Надежда Глебко","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;список;датафрейм;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;элементы нескольких столбцов и строк;целый столбец;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;столбец матрицы является массивом","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","D","0.00 / 1","B","1.00 / 1","A","0.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/09 5:35:28 PM GMT+3","24.00 / 26","Алмара Кулиева","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;датафрейм;список;вектор","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;один элемент в конкретных столбце и строке;целую строку;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/11 2:08:18 PM GMT+3","22.00 / 26","Фрол Сапронов ","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;список;вектор;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;строка датафрейма является вектором;столбец матрицы является массивом","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/15 1:35:08 AM GMT+3","23.00 / 26","Екатерина Косова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;датафрейм;список;вектор","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/15 6:48:05 PM GMT+3","24.00 / 26","Анастасия Расторгуева","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;список;вектор;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;целую строку;один элемент в конкретных столбце и строке;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/16 5:32:35 PM GMT+3","17.00 / 26","Склеменова Лера","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, logical, float","0.00 / 1","Неа :(
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    NA    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;вектор;список;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;один элемент в конкретных столбце и строке;целый столбец","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","B","0.00 / 1","C","0.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/10/27 11:09:14 PM GMT+3","21.00 / 26","Ксюша Сигнаевская","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;датафрейм;вектор;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;целый столбец;целую строку;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;массивы объединяют объекты разных типов данных","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","только по имени (названию) аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/14 7:51:35 PM GMT+3","20.00 / 26","Анна Насырова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    NA    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;вектор;список","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целый столбец;целую строку;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/14 10:16:51 PM GMT+3","16.00 / 26","Алиса Косикова ","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","string","0.00 / 1","Увы, нет.
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""TRUE""    ""12.5""    ""TRUE""    ""wow""    ""FALSE""","0.00 / 1","Следим за последовательностью:
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;датафрейм;список;вектор","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;целый столбец;целую строку","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;массивы объединяют объекты разных типов данных","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","аргументы","0.00 / 1","функция return()","1.00 / 1","тело","0.00 / 1"
"2023/11/15 4:19:23 PM GMT+3","21.00 / 26","Мария Харчевник","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;вектор;функция;список","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке;целый столбец","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","D","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/15 9:54:58 PM GMT+3","22.00 / 26","Федоринина Надежда","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;датафрейм;вектор;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец;элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/15 11:16:03 PM GMT+3","19.00 / 26","Корниенко Дмитрий","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;список;вектор;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;элементы нескольких столбцов и строк;целый столбец;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","C","0.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 10:14:51 AM GMT+3","21.00 / 26","Александр Миронов","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;датафрейм;список;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целый столбец;один элемент в конкретных столбце и строке;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;столбец матрицы является массивом;датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","D","0.00 / 1","B","1.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 11:11:23 AM GMT+3","20.00 / 26","Диана Князева","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""integer"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;вектор;список","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;один элемент в конкретных столбце и строке;целый столбец;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;датафрейм — это вариант списка","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","D","0.00 / 1","B","1.00 / 1","A","0.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 12:53:22 PM GMT+3","16.00 / 26","Гребеневич-Воронина Анастасия ","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для обозначения пропущенных значений","0.00 / 1","Неточность.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""0""    ""TRUE""    ""match""","0.00 / 1","Следите за руками!
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;список;вектор","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целый столбец;целую строку;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","B","0.00 / 1","C","0.00 / 1","A","0.00 / 1","D","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 3:30:40 PM GMT+3","14.00 / 26","Екатерина Иванова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","factor, complex, integer","0.00 / 1","Неа :(
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""integer"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""TRUE""    ""12.5""    ""TRUE""    ""wow""    ""FALSE""","0.00 / 1","Следим за последовательностью:
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;вектор;датафрейм","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","матрицы и таблицы","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке;целую строку;целый столбец;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;датафрейм — это вариант списка;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","B","0.00 / 1","C","0.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 4:46:49 PM GMT+3","20.00 / 26","Анна Смирнова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""TRUE""    ""12.5""    ""TRUE""    ""wow""    ""FALSE""","0.00 / 1","Следим за последовательностью:
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;список;вектор;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;один элемент в конкретных столбце и строке;целую строку","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","круглые","0.00 / 1","Нет, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;столбец матрицы является массивом","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/16 5:32:28 PM GMT+3","11.00 / 26","мария воронцова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""integer"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""TRUE""    ""12.5""    ""TRUE""    ""wow""    ""FALSE""","0.00 / 1","Следим за последовательностью:
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    NA    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;один элемент в конкретных столбце и строке;целую строку;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","фигурные","0.00 / 1","Нет, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","B","0.00 / 1","D","0.00 / 1","A","0.00 / 1","C","0.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","аргументы","0.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","имя","0.00 / 1"
"2023/11/16 9:52:22 PM GMT+3","18.00 / 26","Варвара Худова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","factor, complex, integer","0.00 / 1","Неа :(
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;датафрейм;список;функция","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целый столбец;один элемент в конкретных столбце и строке;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;в матрице могут встретиться элементы разных типов данных","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","B","0.00 / 1","C","0.00 / 1","A","0.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","и по имени, и по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/17 8:38:58 AM GMT+3","18.00 / 26","Лада Скоробагатько","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;список;вектор","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целую строку;целый столбец;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;датафрейм — это вариант списка","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","B","0.00 / 1","C","0.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","только по имени (названию) аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/18 3:30:02 PM GMT+3","21.00 / 26","Анна Брылева","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;список;вектор;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","матрицы и вектора","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целый столбец;один элемент в конкретных столбце и строке;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/18 4:31:53 PM GMT+3","18.00 / 26","Елизавета Степура","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","factor, integer, float","0.00 / 1","Неа :(
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;список;датафрейм","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","один элемент в конкретных столбце и строке","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/18 7:03:07 PM GMT+3","19.00 / 26","Виолетта Гнусина","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","factor, complex, integer","0.00 / 1","Неа :(
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","в качестве результата логической операции","0.00 / 1","Неточность.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""integer"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;вектор;датафрейм","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","матрицы и таблицы","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец;один элемент в конкретных столбце и строке;элементы нескольких столбцов и строк","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;датафрейм — это вариант списка","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","B","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/19 10:29:53 AM GMT+3","24.00 / 26","Нина Романова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;вектор;функция;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;один элемент в конкретных столбце и строке;элементы нескольких столбцов и строк;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","столбец матрицы является массивом;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/19 11:21:07 AM GMT+3","22.00 / 26","Анастасия Шишунова","-- / 0","","num, int, char, bool","0.00 / 1","Не совсем...
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;вектор;датафрейм","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке;целую строку;целый столбец","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","A","1.00 / 1","Бесспорно.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","или по имени (названию) аргументов, или по порядку аргументов","1.00 / 1","Верно.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/19 1:58:44 PM GMT+3","21.00 / 26","Анастасия Сладкоштиева","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""TRUE""    ""12.5""    ""TRUE""    ""wow""    ""FALSE""","0.00 / 1","Следим за последовательностью:
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    NA    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;список;функция;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец;элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по имени (названию) аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/19 3:10:09 PM GMT+3","20.00 / 26","София Албакова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","integer","0.00 / 1","Увы, нет.
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","6    0    1    NA","0.00 / 1","Следите за руками!
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","NA    2    NA","1.00 / 1","Всё так!
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","функция;список;вектор;датафрейм","1.00 / 1","Действительно.
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","вектора и списка","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","элементы нескольких столбцов и строк;целую строку;целый столбец;один элемент в конкретных столбце и строке","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","вектор является одномерным массивом;все векторы в датафрейме имеют одинаковое количество элементов","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","строка датафрейма является вектором;датафрейм — это вариант списка","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/19 10:27:58 PM GMT+3","17.00 / 26","Элина Шаипова ","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","датафрейм;список;вектор","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","матрицы и вектора","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","в матрице могут встретиться элементы разных типов данных;все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","0.00 / 1","Разберемся.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;строка датафрейма является вектором","0.00 / 1","Изучим вопросик внимательно.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","D","0.00 / 1","B","1.00 / 1","A","0.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по имени (названию) аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/21 3:06:37 AM GMT+3","16.00 / 26","Оксана Кожевникова","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""string"", ""logical""","0.00 / 1","Разберемся.
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","вектор;датафрейм;список","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","списка и матрицы","1.00 / 1","Да, датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целую строку;целый столбец","0.00 / 1","Возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","A","0.00 / 1","D","0.00 / 1","B","1.00 / 1","C","0.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет выполнять все операции/функции тела, не будет возвращать никакого значения","0.00 / 1","Согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции. Просто это так работает.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"
"2023/11/21 3:40:13 PM GMT+3","21.00 / 26","Александрова Алиса","-- / 0","","numeric, logical, character, factor","1.00 / 1","Всё так!
К основным типа данных R относятся numeric, logical, character и factor.
String не является типом данных в R. Boolean и bool иногда используется как синоним logical, однако это не основное название данного типа. Num, int и char могут встречатся как сокращения названий типов данных R.","boolean","1.00 / 1","Истина!
Logical — это логический тип данных, иначе называемый boolean. Integer — это целые числа.
Float и string не являются названиями типов данных R.","integer, complex, double","1.00 / 1","Всё верно!
Factor содержит в себе строки, хотя они и кодируются числами, float не является типом данных R, а logical представляет собой логический тип данных.
Получается, числовые типы в R — это integer, complex и double.","для передачи пустого значения в аргумент функции","1.00 / 1","Справедливо.
NULL используется для передачи пустого значения в аргумент функции.
Для обозначения пропущенных значений используется NA, в качестве результата ошибки математической операции используется NaN, а результатом логической операции может быть либо TRUE, либо FALSE.","""numeric"", ""character"", ""character""","1.00 / 1","Совершенно справедливо!
17 — это число. Все числа по умолчанию воспринимаются R как numeric. Если хотим integer, то надо написать 17L.
'e' — это текст, то есть character, даже если это один символ, записанный в одинарных кавычках.
""True"" — это тоже текст, так как записан в кавычках, несмотря на то, что он содержит строку True.","""6""    ""FALSE""    ""TRUE""    ""match""","1.00 / 1","Да, схема такая:
Сначала во «внутреннем» вектор TRUE будет приведено к строковому типу — получится
""TRUE""    ""match""
Затем весь «внешний» вектор будет к строковому типу — получится
""6""    ""FALSE""    ""TRUE""    ""match""","""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","1.00 / 1","Ровно так!
Сначала случится приведение типов в векторе c(TRUE, 12.5, TRUE) — получится
1    12.5    1
Затем случится приведение типов в векторе c(""wow"", FALSE) — будет
""wow""    ""FALSE""
Далее при объединении векторов числа будут приведены к строкам — итого
""1""    ""12.5""    ""1""    ""wow""    ""FALSE""","0    2    NA","0.00 / 1","Тут есть хитрости.
При приведении FALSE к числу возникает неоднозначность, так как любое число, кроме единицы, это FALSE — поэтому возникает NA. При приведении строки ""s"" к числу тоже возникает NA, так как неясно, какое число в соответствие такой строке поставить. ""2"" же приводится к числу однозначно.","список;датафрейм;вектор","0.00 / 1","Вопросец с подвохом :)
В R объектом может быть всё что угодно.","словарь","1.00 / 1","Да, именно словарь не реализован в R.","вектора и списка","0.00 / 1","Близко, но нет :(
Датафрейм наследует от списка возможность совмещения разных типов данных, а от матрицы — организацию строк и столбов.","целый столбец;элементы нескольких столбцов и строк;один элемент в конкретных столбце и строке;целую строку","1.00 / 1","Да, возможны все варианты.
Пусть m — это матрица из 5 строк и 5 столбцов. Тогда:
целый столбец — m[ , 1]
целый строка — m[1, ]
элементы нескольких столбцов и строк — m[1:2, 3:4]
один элементы в конкретных столбце и строке — m[1, 5]","квадратные","1.00 / 1","Ага, для индексации всегда используются квадратные скобки — и не важно, какой объект мы индексируем.
Круглые используются для обозначения порядка действий, а также в условных операторах и циклах. Фигурные встречаются при создании функции, обозначая тело функции, и в условных операторах и циклах, где также обозначают их тела. Угловых скобок в R нет.","все векторы в датафрейме имеют одинаковое количество элементов;вектор является одномерным массивом","1.00 / 1","И правда.
Элементом списка может быть что угодно, в том числе и другой список.
Матрица является массивом, поэтому в ней могут содержаться элементы только одного типа.
Вектор действительно является одномерным массивом, так как все элементы одного типа в нем лежат «в ряд».
Датафрейм состоит из векторов, которые являются его столбцами, поэтому они все должны быть одинаковой длины, то есть содержать одинаковое количество элементов.","датафрейм — это вариант списка;столбец матрицы является массивом","1.00 / 1","Совершенно справедливо.
Строка датафрейма не может быть вектором, так как она может содержать элементы разных типов данных — из разных столбцов.
Массивы по определению объединяют элементы одного типа.
Столбец матрицы является массивом, так как он объединяет элементы одного типа, потому что и матрица в целом объединяет элементы одного типа. Вообще столбец матрицы рассматривается как частный случай матрицы.
Датафрейм — это список векторов одинаковой длины.","C","1.00 / 1","A","1.00 / 1","B","1.00 / 1","D","1.00 / 1","C","0.00 / 1","Поищем ошибки.
В — для задания использованы квадратные скобки, а должны быть круглые.
С — прописано дополнительное условие после else, хотя тело else выполняется в случае, если не были выполнены условия выше.
D — пропущены фигурные скобки, R не поймет, где начинается тело if и где оно заканчивается, и аналогично с телом else. [Питоновские отступы в R не работают.]
А — тут ошибки нет, так как else if выполнился в случае, если первое условие ложно, а второе — истинно. Если оба ложны, не выполнится ни одно.","будет возвращать результат последней выполненной в теле операции/функции","1.00 / 1","Да, согласно логике работы функции в R, если не прописан return(), она будет возвращать результат последней выполненной операции.","только по порядку аргументов","0.00 / 1","Неа.
Чтобы функция корректно отработала, нужно либо соблюсти порядок её аргументов, либо передать их по именам. Выполнение обоих условий не обязательно. Так, передавая аргументы по именам, можно нарушить их порядок — это не скажется на работе функции.","имя","1.00 / 1","тело","1.00 / 1","функция return()","1.00 / 1","аргументы","1.00 / 1"