# P5 // Визуализация данных {#pr5 .unnumbered}

```{=html}
<!--
REPLACE ALL pr5 TO pr<n> WITH MATCH CASE
-->
```

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, error=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, message = FALSE, error = FALSE)
```

## Основные задания {#pr5_main}

::: {.callout-note}
### Описание данных

Сегодня мы будем работать с данными о бриллиантах. Это датасет `diamonds`, который входит в пакет `ggplot2`.

```{r data-desc}
ggplot2::diamonds
```

В нем есть следующие переменные:

* `carat` --- вес бриллианта (в каратах)
* `cut` --- качество огранки
* `color` --- цвет бриллианта (от `D` --- худший --- до `J` --- лучший)
* `clarity` --- чистота бриллианта (от `I1` --- худшее --- до `IF` --- лучшее)
* `x`, `y`, `z` --- длина, ширина и высота бриллианта (в миллиметрах)
* `depth` --- глубина бриллианта, рассчитываемая как $\frac{2z}{xy}$
* `table` --- отношение ширины верхней площадки блиррианта к его наибольшей ширине
* `price` --- цена бриллианта (в долларах США)

:::

### #1 {#pr5-1}

<img id="pr5-1-level" class="level"/>

::: {#pr5-1-task .task}

* Подгрузите пакет `tidyverse` к текущей сессии R.
* Проверье доступен ли вам датасет `diamonds` из пакета `ggplot2`. Выведите структуру датасета, посмотрите, какие переменные и какого типа в нём содержатся.
* Отберите 1000 случайных строк из данных и сохраните их в переменную `diam1000`. Используйте `set.seed(123)`.

:::

```{r 1}
library(tidyverse)
# str(diamonds)

set.seed(123)
diamonds %>% 
    slice(sample(1:nrow(diamonds), 1000)) -> diam1000
```

::: {#pr5-1-autocheck .autocheck}
::: {#pr5-1-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-1" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-1')">

::: {#pr5-1-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-1-hints">

<summary>Подсказки</summary>

* Чтобы получить доступ к датасету `diamonds`, достаточно подключть пакет `tidyverse`. Отдельно подгружать `ggplot2` не нужно, так как он подгружается в месте с другими пакетами `tidyverse`.
* Отобрать строки можно с помощью функции `slice()`.
* Сгенерировать 1000 случайных значений поможет функция `sample()`.

</details>
:::

### #2 {#pr5-2}

<img id="pr5-2-level" class="level"/>

::: {#pr5-2-task .task}

Давайте визуализирует связаимосвязь между длиной (`x`) и шириной (`y`) бриллиантов. Возьмем для этого маленький датасет из 100 наблюдений (`diam1000`).

a. Создайте базовый слой для визуализации.

```{r 2a}
diam1000 %>% 
  ggplot()
```

b. Расчертите оси на базовом слое. По оси `x` пойдёт длина бриллианта, а по оси `y` его ширина.

```{r 2b}
diam1000 %>% 
  ggplot(aes(x, y))
```
:::

::: {#pr5-2-autocheck .autocheck}
::: {#pr5-2-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-2" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-2')">

::: {#pr5-2-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-2-hints">

<summary>Подсказки</summary>

* Построение графика начинается с функции `ggplot()`
* Для задания осей используется функция `aes()` внутри функции `ggplot()`

</details>
:::

### #3 {#pr5-3}

<img id="pr5-3-level" class="level"/>

::: {#pr5-3-task .task}
Отлично! Мольберт мы достали. Теперь надо сказать `ggplot`у, как мы будем отображать наши наблюдения.

a. Перейдите на новый слой и задайте отображение наблюдений с помощью точек.

```{r 3a}
diam1000 %>% 
    ggplot(aes(x, y)) +
    geom_point()
```

b. Добавьте ещё один слой с линией тренда.

```{r 3b}
diam1000 %>% 
    ggplot(aes(x, y)) +
    geom_point() +
    geom_smooth()
```

:::

::: {#pr5-3-autocheck .autocheck}
::: {#pr5-3-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-3" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-3')">

::: {#pr5-3-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-3-hints">

<summary>Подсказки</summary>

* Чтобы перейти на новый слой, понадобится оператор `+`
* За то, как будут отображаться наблюдения, отвечают функции `geom_..()`
* Линия тренда --- это сглаживание (smoothing) отображаемой зкономерности.

</details>
:::

### #4 {#pr5-4}

<img id="pr5-4-level" class="level"/>

::: {#pr5-4-task .task}

Сгруппируйте бриллианты по уровню чистоты (`clarity`), отобразив эту переменную с помощью цвета.

```{r 4}
diam1000 %>% 
    ggplot(aes(x, y, color = clarity)) +
    geom_point() +
    geom_smooth()
```

:::

::: {#pr5-4-autocheck .autocheck}
::: {#pr5-4-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-4" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-4')">

::: {#pr5-4-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-4-hints">

<summary>Подсказка</summary>

Функция `aes()` задает в общем случае вообще любые эстетики --- форматирование графика, связанное с данными. Оси --- это лишь частный случай эстетик.

</details>
:::

### #5 {#pr5-5}

<img id="pr5-5-level" class="level"/>

::: {#pr5-5-task .task}
Супер! Мы разобрались с базовыми принципами работы в `ggplot()` --- эстетики, слои, геомы. Теперь нарисует что-то более серьезное. Будем теперь работать с полным датасетом `diamonds`.

В `ggplot2` есть функции, которые позволяют прямо при построении графика агрегировать наши данные. Воспользуемся их возможностями.

a. Визуализируйте зависимость средней цены бриллиантов (`price`) от качества огранки (`cut`).

```{r 5a}
diamonds %>% 
    ggplot(aes(cut, price)) +
    stat_summary(fun = mean, geom = "point")
```

b. Добавьте к средним доверительные интервалы --- так визуализация будет более корректно отображать закономерность.

```{r 5b}
diamonds %>% 
    ggplot(aes(cut, price)) +
    stat_summary(fun.data = mean_cl_boot, geom = "errorbar") +
    stat_summary(fun = mean, geom = "point")
```

:::

::: {#pr5-5-autocheck .autocheck}
::: {#pr5-5-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-5" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-5')">

::: {#pr5-5-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-5-hints">

<summary>Подсказки</summary>

* Чтобы агрегировать данные внутри `ggplot2`, есть функция `stat_summary()`
* Если в результате агрегации получается одно значение, его необходимо передавать в аргумент `fun`. Если несколько, то `fun.data`.
* Среднее рассчитывается классически. Доверительный интервал можно получить через `mean_cl_boot`.
* Иногда функция падает и просит установить пакет `Hmisc`. Он устанавливается как и любой другой пакет через `install.packages()`.

</details>
:::

### #6 {#pr5-6}

<img id="pr5-6-level" class="level"/>

::: {#pr5-6-task .task}

Визуализация какая-то слишком простенькая. Давайте добавим еще переменных.

a. Сгруппируйте бриллианты по цвету (`color`), отобразив эту переменную с помощью цвета на графике.

```{r 6a}
diamonds %>% 
    ggplot(aes(cut, price, color = color)) +
    stat_summary(fun.data = mean_cl_boot, geom = "errorbar") +
    stat_summary(fun = mean, geom = "point")
```

Мда... Получилось какое-то дикое месиво. Давайте немного причешем визуализацию. Например, подправим расположение точек, чтобы они лежали не на одной прямой, а рядом друг с другом --- ведь небольшие отклонения вправо-влево по оси `x` для нас не имеют значения, так как по горизонтальной оси расположена категориальная переменная.

b. Расположите средние и доверительные интервалы рядом друг с другом, не потеряв при этом уже заданные группировки.

```{r 6b}
pd <- position_dodge(0.5)
diamonds %>% 
    ggplot(aes(cut, price, color = color)) +
    stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
                 position = pd) +
    stat_summary(fun = mean, geom = "point",
                 position = pd)
```

Стало гораздо приятнее. Однако вы видим, что горизонтальные линии, обозначающие границы доверительных интервалов, слишком длинные и касаются друг друга. Надо обеспечить их личным пространством.

с. Уменьшите ширину горизонтальный линий на границах доверительных интервалов, чтобы они не касались друг друга.

```{r 6c}
pd <- position_dodge(0.5)
diamonds %>% 
    ggplot(aes(cut, price, color = color)) +
    stat_summary(fun.data = mean_cl_boot, geom = "errorbar",
                 position = pd, width = .4) +
    stat_summary(fun = mean, geom = "point",
                 position = pd)
```


:::

::: {#pr5-6-autocheck .autocheck}
::: {#pr5-6-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-6" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-6')">

::: {#pr5-6-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-6-hints">

<summary>Подсказки</summary>

* За положение элементов относительно друг друга отвечает аргумент `position`.
* Чтобы поставить элементы рядом, пригодится функция `position_dodge()`.
* У каждого геома есть много настроек, которые называются весьма интуитивно. Например, ширину горизонтальный линий errorbar'ов задает аргумент `width`.

</details>
:::

### #7 {#pr5-7}

<img id="pr5-7-level" class="level"/>

::: {#pr5-7-task .task}
Супер! Мы критически близки к успеху! Осталось поработать над оформлением графика.

a. Измените тему визуализации на черно-белую, чтобы картинка стала более контрастной.

```{r 7a}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw()
```

b. У нас на графике есть легенда, которая занимает прилично так места справа. Сместите её вниз, чтобы пространство графика использовалось более оптимально.

```{r 7b}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom")
```

:::

::: {#pr5-7-autocheck .autocheck}
::: {#pr5-7-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-7" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-7')">

::: {#pr5-7-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-7-hints">

<summary>Подсказки</summary>

* Сменить тему всего графика можно используя предустановленные темы `ggplot2`, которые задаются через ноывй слой. Есть много тем, однако наиболее важные для нас и часто используемые это `theme_bw()` и `theme_minimal()`.
* Тему можно кастомизировать практически как угодно. Для этого есть масса аргументов функции `theme()`. Так, позицию легенды можно задать через аргумент `legend.position`.

</details>
:::

### #8 {#pr5-8}

<img id="pr5-8-level" class="level"/>

::: {#pr5-8-task .task}
Поработаем над цветовой палитрой. Она неплоха, но некоторые цвета можно спутать, а желтый на белом фоне выглядит крайне неконтрастно.

Задайте собственную цветовую палитру для графика.

В примере ниже использован пакет `colorspace`, в котором есть уже предустановленные цветовые палитры.

:::

```{r 8}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = colorspace::rainbow_hcl(diamonds$color %>%
                                                        unique() %>% length()))
```

::: {#pr5-8-autocheck .autocheck}
::: {#pr5-8-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-8" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-8')">

::: {#pr5-8-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-8-hints">

<summary>Подсказки</summary>

* Кастомизировать экстетики можно с помощью фукнций `scale_.._..()`.

</details>
:::

### #9 {#pr5-9}

<img id="pr5-9-level" class="level"/>

::: {#pr5-9-task .task}

Почти готово! Осталось только подписать оси так, чтобы было понятно, что это такое.

Задайте русские названия осей и легенды, а также добавьте заголовок, подзаголовок и подпись на график.

```{r 9}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = colorspace::rainbow_hcl(diamonds$color %>%
                                                        unique() %>%
                                                        length())) +
  labs(
    x = "Качество огранки",
    y = "Цена",
    color = "Цвет",
    title = "Зависимость цены бриллианта от его характеристик",
    subtitle = "Качество огранки и цвет",
    caption = "отображен 95% доверительный интервал"
  )
```

:::

::: {#pr5-9-autocheck .autocheck}
::: {#pr5-9-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-9" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-9')">

::: {#pr5-9-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-9-hints">

<summary>Подсказки</summary>

Чтобы задать различные подписи для графика, пригодится функция `labs()` (от labels).

</details>
:::

### #10  {#pr5-10}

<img id="pr5-10-level" class="level"/>

::: {#pr5-10-task .task}
Ну, вот мы и построили публикабельную визуализацию. Чтобы её можно было отправить куда-либо --- в журнал, на постер, в презентацию --- её необходимо экспортировать.

Экспортируйте построенный график в формате JPEG, размером 20×20 см в таком разрешении, чтобы он качественно смотрелся в печатном виде.
:::

```{r 10, eval=FALSE}
ggsave('graph1.png', width = 20, height = 20, units = 'cm', dpi = 600)
```

::: {#pr5-10-autocheck .autocheck}
::: {#pr5-10-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-10" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-10')">

::: {#pr5-10-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-10-hints">

<summary>Подсказки</summary>

* Сохранить построенную визуализацию поможет функция `ggsave()`.
* В ней можно задать все необходимые параметры --- размер, разрешение, формат файла.
* Подходящим для печати разрешением считается 600 dpi (dots per inch, точки на дюйм).

</details>
:::

### #11 {#pr5-11}

<img id="pr5-11-level" class="level"/>

::: {#pr5-11-task .task}

Мы задали тему графика внутри кода его построения. В таком случае, когда мы начнем строить другой график, будет импользована дефолтная серая тема.

Установите черно-белую тему на всю сессию работы R.

:::

```{r 11}
theme_set(theme_bw())
```

::: {#pr5-11-autocheck .autocheck}
::: {#pr5-11-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-11" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-11')">

::: {#pr5-11-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-11-hints">

<summary>Подсказки</summary>

Есть крайне полезная функция `theme_set()`, которая позволяет установить какую-либо тему для всей текущей сессии R --- тогда нам не придется задавать тему для каждого графика отдельно.

</details>

:::

### #12 {#pr5-12}

<img id="pr5-12-level" class="level"/>

::: {#pr5-12-task .task}
Посмотрим на другие способы визуализации разных переменных.

a. Визуализируйте распределение цены бриллиантов с помощью гистограммы.

```{r 12a}
diamonds %>% 
    ggplot(aes(price)) +
    geom_histogram()
```

На такой визуализации мы видим распределение цены в целом. Однаконам может быть интересно распределение цены в зависимости от каких-либо других характеристик.

b. Визуализируйте распределение цены бриллиантов в зависимости от их цвета (`color`). Отобразите группирующую переменную с помощью цвета заливки столбиков гистограммы.

```{r 12b}
diamonds %>% 
    ggplot(aes(price, fill = color)) +
    geom_histogram()
```

Симпатишно, но не то чтобы очень интерпретабельно. Надо найти другой способ отображения группировки.

c. Визуализируйте распределение цены бриллиантов в зависимости от их цвета. Отобразите группирующую переменную так, чтобы каждая группа была расположена на отдельном подграфике.

```{r 12c}
diamonds %>% 
    ggplot(aes(price)) +
    geom_histogram() + 
  facet_wrap(~ color)
```
:::

::: {#pr5-12-autocheck .autocheck}
::: {#pr5-12-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-12" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-12')">

::: {#pr5-12-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-12-hints">

<summary>Подсказки</summary>

* Для отображения гистограммы есть специально обученный геом.
* Значения оси `y` при построении гистограммы рассчитываются автоматически.
* Разбиение графика на несколько подграфиков называется фасетированием. Для этого придуманы функции `facet_..()`.

</details>
:::

### #13 {#pr5-13}

<img id="pr5-13-level" class="level"/>

::: task
a. Визуализируйте распределение цены (без разбиений по каким-либо переменным) с помощью графика плотности распределения.

```{r 13a}
diamonds %>% 
    ggplot(aes(price)) +
    geom_density()
```

b. Разбейте график плоности распределения на подграфики так, чтобы они выстроились в сетку, в которой по строкам будут идти категории качества огранки, а по столбцам --- цвета бриллиантов.

```{r 13b}
diamonds %>% 
    ggplot(aes(price)) +
    geom_density() +
  facet_grid(cut ~ color)
```
:::

::: {#pr5-13-autocheck .autocheck}
::: {#pr5-13-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-13" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-13')">

::: {#pr5-13-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-13-hints">

<summary>Подсказки</summary>

</details>
:::

### #14 {#pr5-14}

<img id="pr5-14-level" class="level"/>

::: {#pr5-14-task .task}

Постройте столбчатую диаграмму, которая будет отображать частоты по переменной `color` (цвет бриллианта).

:::

```{r}
diamonds %>% 
  ggplot(aes(color)) +
  geom_bar()

# diamonds %>% 
#   summarise(n = n(),
#             .by = color) %>% 
#   ggplot(aes(color, n)) +
#   geom_col()
```

::: {#pr5-14-autocheck .autocheck}
::: {#pr5-14-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-14" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-14')">

::: {#pr5-14-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-14-hints">

<summary>Подсказки</summary>

Здесь может быть два варианта --- первый через `geom_bar()`, второй через  `geom_col()`.

</details>
:::

### #15 {#pr5-15}

<img id="pr5-15-level" class="level"/>

::: {#pr5-15-task .task}

Если для распределения дискретной переменной у нас не так много возможностей визуализации, то для распределения непрерывной их гораздо больше.

Визуализируйте распределение цены бриллиантов в зависимости от категории чистоты с помощью ящиков с усами.

```{r 15}
diamonds %>% 
  ggplot(aes(clarity, carat)) +
  geom_boxplot() 
```

:::

::: {#pr5-15-autocheck .autocheck}
::: {#pr5-15-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-15" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-15')">

::: {#pr5-15-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-15-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

### #16 {#pr5-16}

<img id="pr5-16-level" class="level"/>

::: {#pr5-16-task .task}

a. Замените ящики с усами на violin plot'ы.

```{r 16a}
diamonds %>% 
  ggplot(aes(clarity, carat)) +
  geom_violin()
```

b. Замените данные с `diamonds` на `diam1000` и добавьте на график средние с доверительными интервалами. Используйте `geom_pointrange()`.

```{r 16b}
diam1000 %>% 
  ggplot(aes(clarity, carat)) +
  geom_violin() +
  stat_summary(fun.data = mean_cl_boot,
               geom = "pointrange")
```

c. Добавьте на график точки самих наблюдений. Чтобы можно было увидеть, какие точки накладываются друг на друга, задайте им непрозрачность 20%, а чтобы средние с доверительными интервалами выделялись, покрасьте их в синий.

```{r 16c}
diam1000 %>% 
  ggplot(aes(clarity, carat)) +
  geom_violin() +
  geom_point(position = position_dodge(.4),
             alpha = .2) +
  stat_summary(fun.data = mean_cl_boot,
               geom = "pointrange",
               color = "blue")
```
:::

::: {#pr5-16-autocheck .autocheck}
::: {#pr5-16-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-16" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-16')">

::: {#pr5-16-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-16-hints">

<summary>Подсказки</summary>

* Форматирование графика, которое не связано с данными, задается вне функции `aes()` с помощью тех же аргументов.
* [Не]прозрачность --- это альфа-канал изображения.

</details>
:::

### #17 {#pr5-17}

<img id="pr5-17-level" class="level"/>

::: {#pr5-17-task .task}
Теперь построим визуализацию корреляционной матрицы. Для этого есть удобная функция `ggcorrplot()` из пакета `ggcorrplot`.

Нам будут нужны новые данные. Будем использовать [результаты апробации опросника на доверие к искусственному интелекту](https://raw.githubusercontent.com/angelgardt/wlm2023/master/data/pr5/taia_items.csv). В этих данных есть колонка `id`, которая задает идентификатор респондента, а все оставшиеся --- это пункты опросника, относящиеся к разным шкалам.

Визуализируем корреляции между баллами пунктов по шкале predictability (`pr`).

Функция `ggcorrplot()` обязательным аргументов требует корреляционную матрицу. Построим её с помощью следующего кода:

```{r 17 data, echo=TRUE}
# загрузим данные
taia <- read_csv("https://raw.githubusercontent.com/angelgardt/wlm2023/master/data/pr5/taia_items.csv", show_col_types = FALSE)

taia %>% select(starts_with("pr")) %>% cor() -> cormat
```

Полученная матрица `cormat` и есть необходимая нам корреляционная матрица.

Визуализируйте взаимосвязи между пунктами шкалы predictability с помощью корреляционный матрицы.

```{r 17}
ggcorrplot::ggcorrplot(cormat)
```

:::

::: {#pr5-17-autocheck .autocheck}
::: {#pr5-17-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-17" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-17')">

::: {#pr5-17-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-17-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

### #18 {#pr5-18}

<img id="pr5-18-level" class="level"/>

::: {#pr5-18-task .task}
В прицнипе, визуализация построена, однако она весьма нехороша. Логичнее было бы отобразить положительные корреляции холодными оттенками, а отрицательные теплыми, так как мы ожидаем положительные корреляции, а красный сигнализирует нам о том, что что-то идет не так.

Кроме того, корреляционная матрица симметрична, поэтому можно отобразить только её нижний угол. И хорошо бы добавить сами значения корреляций на график --- тогда легенда будет не нужна. Название графика также облегчит понимание, что это такое.

Настройте отображение матрицы в соответствии с описанием выше.

:::

```{r 18}
ggcorrplot::ggcorrplot(cormat,
                       type = "lower", lab = TRUE,
                       colors = c("indianred", "white", "royalblue"),
                       show.legend = FALSE,
                       title = "Predictability. Interitem correlations")
```

::: {#pr5-18-autocheck .autocheck}
::: {#pr5-18-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-18" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-18')">

::: {#pr5-18-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-18-hints">

<summary>Подсказки</summary>

Аргументы функции  `ggcorrplot()`, которые пригодятся:

* `type`
* `lab`
* `colors`
* `show.legend`
* `title`

</details>
:::

### #19 {#pr5-19}

<img id="pr5-19-level" class="level"/>

::: {#pr5-19-task .task}
На первых двух практиках мы генерировали случайные числа и укладывали их в векторы и матрицы. Это все было не просто так. Мы можем использовать их для визуализации статистических закономерностей. 

С содержательной стороной вопроса познакомимся совсем скоро --- пока же изучим техническую.

a. Сгенерируйте 20 выборок по 30 наблюдений из нормального распределения (`rnorm()`) с параметрами `mean = 5` и `sd = 2`. Сохраните результат в матрицу `sim` размером 30×20. Используйте `set.seed(999)`.

```{r 19a}
set.seed(999)
sim <- matrix(rnorm(30*20, mean = 5, sd = 2), ncol = 20)
```

b. Визуализируйтер распределение сгенерированной случайной величины в каждой из выборок на одном графике.

```{r 19b}
sim %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~ name)
```

:::

::: {#pr5-19-autocheck .autocheck}
::: {#pr5-19-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-19" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-19')">

::: {#pr5-19-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-19-hints">

<summary>Подсказки</summary>

Понадобится перевести данные из широкого формата в длинный.

</details>
:::

### #20 {#pr5-20}

<img id="pr5-20-level" class="level"/>

::: {#pr5-20-task .task}

Чтобы изучать, как работает статистика, нам понадобиться добавлять на графики некоторые дополнительные элементы. В данном случае, было бы интересно увидеть, как соотносятся получившиеся распределения со средним значением `mean`, которое мы задавали при генерации нашей переменной.

Добавьте на визуализацию отображение параметра `mean`, который мы использовали внутри функции `rnorm()`, с помощью вертикальной линии.

:::

```{r 20}
sim %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything()) %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~ name) +
  geom_vline(xintercept = 5)
```

::: {#pr5-20-autocheck .autocheck}
::: {#pr5-20-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-20" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-20')">

::: {#pr5-20-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-20-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

## Дополнительные задания {#pr5_add}

### #1 {#pr5-21}

<img id="pr5-21-level" class="level"/>

::: {#pr5-21-task .task}

Иногда возникает задача изменить дефолтные шрифты на графике. По умолчанию для графиков берется шрифт без засечек --- какой именно, зависит от операционной системы.

Возьмите график, получившийся в [задании 9](#pr5-9), и замените дефолтный шрифт на шрифт с засечками Times New Roman.

:::

```{r 21}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = colorspace::rainbow_hcl(diamonds$color %>%
                                                        unique() %>%
                                                        length())) +
  labs(
    x = "Качество огранки",
    y = "Цена",
    color = "Цвет",
    title = "Зависимость цены бриллианта от его характеристик",
    subtitle = "Качество огранки и цвет",
    caption = "отображен 95% доверительный интервал"
  ) +
  theme(
    text = element_text(family = "Times New Roman")
  )
```

::: {#pr5-21-autocheck .autocheck}
::: {#pr5-21-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-21" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-21')">

::: {#pr5-21-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-21-hints">

<summary>Подсказки</summary>

* Шрифты являются частью темы, поэтому настраиваются через функцию `theme()`.
* У функции `theme()` есть аргумент `text`, который принимает результат работы функции `element_text()`.
* У функции `element_text()` есть аргумент `family`, через который можно указать семейство шрифтов, которое необходимо использовать при построении графика.

</details>
:::



### #2 {#pr5-22}

<img id="pr5-22-level" class="level"/>

::: {#pr5-22-task .task}

Настроить можно не только тип шрифта, но и кегль.

Учеличьте кегль подписей оси `y` до 12.

:::

```{r 22}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = colorspace::rainbow_hcl(diamonds$color %>%
                                                        unique() %>%
                                                        length())) +
  labs(
    x = "Качество огранки",
    y = "Цена",
    color = "Цвет",
    title = "Зависимость цены бриллианта от его характеристик",
    subtitle = "Качество огранки и цвет",
    caption = "отображен 95% доверительный интервал"
  ) +
  theme(
    text = element_text(family = "Times New Roman"),
    axis.text.y = element_text(size = 12)
  )
```

::: {#pr5-22-autocheck .autocheck}
::: {#pr5-22-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-22" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-22')">

::: {#pr5-22-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-22-hints">

<summary>Подсказки</summary>

* У функции `theme()` есть еще ряд аргументов. Например, можно задать отдельно параметры названия осей (`axis.title.x`, `axis.title.y`) и подписей значений осей (`axis.text.x`, `axis.text.y`)
* Эти аргументы также принимают результат работы функции `element_text()`.
* У функции `element_text()` есть аргумент `size`.

</details>
:::

### #3 {#pr5-23}

<img id="pr5-23-level" class="level"/>

::: {#pr5-23-task .task}

А ещё можно развернуть подписи осей на какой-то угол.

Поверните подписи оси `x` на 90 градусов.

:::


```{r 23}
diamonds %>%
  ggplot(aes(cut, price, color = color)) +
  stat_summary(
    fun.data = mean_cl_boot,
    geom = "errorbar",
    position = pd,
    width = .4
  ) +
  stat_summary(fun = mean,
               geom = "point",
               position = pd) +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = colorspace::rainbow_hcl(diamonds$color %>%
                                                        unique() %>%
                                                        length())) +
  labs(
    x = "Качество огранки",
    y = "Цена",
    color = "Цвет",
    title = "Зависимость цены бриллианта от его характеристик",
    subtitle = "Качество огранки и цвет",
    caption = "отображен 95% доверительный интервал"
  ) +
  theme(
    text = element_text(family = "Times New Roman"),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(angle = 90)
  )
```

::: {#pr5-23-autocheck .autocheck}
::: {#pr5-23-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-23" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-23')">

::: {#pr5-23-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-23-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

### #4 {#pr5-24}

<img id="pr5-24-level" class="level"/>

::: {#pr5-24-task .task}

При отображении распределений бывает полезно визуализировать, какую часть из распределения все переменной составляет распределение в какой-то конкретной группе.

* Возьмите график из [задания 12с](#pr5-12) и добавьте в фасеты распределение цены позади распределений в каждой группе по цвету.
Используйте для общей гистограммы цвет `gray70`.
* Чтобы гистограммы в каждой группе лучше отличались от общей гистограммы, раскрасьте их по переменной `color`.
* Скройте легенду, так как цвет дублирует деление по фасетам и не несет дополнительной нагрузки.

:::

```{r 24}
ggplot() +
  geom_histogram(data = diamonds %>% select(-color), aes(price), fill = "gray70") +
  geom_histogram(data = diamonds, aes(price, fill = color)) +
  facet_wrap(~ color) +
  guides(fill = "none")
```

::: {#pr5-24-autocheck .autocheck}
::: {#pr5-24-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-24" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-24')">

::: {#pr5-24-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-24-hints">

<summary>Подсказки</summary>

* Понадобится сделать два слоя с гистограммами, в каждом из которых необходимо отдельно задать датасет.
* На слое с общей гистограммой необходимо удалить колонку `color`, чтобы невозможно было поделить наблюдения по группам.
* Скрыть переменную из легенды можно с помощью функции `guides()`.

</details>
:::

### #5 {#pr5-25}

<img id="pr5-25-level" class="level"/>

::: {#pr5-25-task .task}

В [задании 14](#pr5-14) мы построили столбчатую диаграмму, в которой столбцы располагаются в порядке, заданном в переменной `color` --- это упорядоченный вектор. Однако в ряде случаев бывает разумно расположить столбцы в порядке частот.

Задайте порядок отображения столбцов диаграммы по частоте от наибольшей до наименьшей.

:::

```{r 25}
diamonds %>%
  summarise(n = n(),
            .by = color) %>%
  ggplot(aes(fct_rev(fct_reorder(color, n)), n)) +
  geom_col() +
  labs(x = "color")
```

::: {#pr5-25-autocheck .autocheck}
::: {#pr5-25-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-25" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-25')">

::: {#pr5-25-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-25-hints">

<summary>Подсказки</summary>

* Для работы с факторными переменными в пакете `forcats`, который является частью `tidyverse`, есть много функций. Две, которые пригодятся тут: `fct_reorder()` и `fct_rev()`.
* Понадобиться вариант построения графика через `geom_col()`.

</details>
:::

### #6 {#pr5-26}

<img id="pr5-26-level" class="level"/>

::: {#pr5-26-task .task}

И добавим еще один слой на столбчатую диаграмму. По оси `y` отображена частота --- это да, однако не всегда можно достаточно точно определить, сколько именно бриллиантов того или итого цвета.

Добавьте лейблы на столбцы диаграммы, на которых будет указанно количество бриллиантов в каждой группе по цвету.

:::

```{r 26}
diamonds %>%
  summarise(n = n(),
            .by = color) %>%
  ggplot(aes(fct_rev(fct_reorder(color, n)), n)) +
  geom_col() +
  geom_label(aes(label = n)) +
  labs(x = "color")
```

::: {#pr5-26-autocheck .autocheck}
::: {#pr5-26-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-26" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-26')">

::: {#pr5-26-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-26-hints">

<summary>Подсказка</summary>

`geom_label()`

</details>
:::

### #7  {#pr5-27}

<img id="pr5-27-level" class="level"/>

::: {#pr5-27-task .task}

Совсем скоро мы начнем изучать статистические модели, и будем изучать, насколько они хорошо работают на тех или иных данных. Для этого будем рисовать графики, на которых отображены значения из данных и предсказанные значения модели. Очень много не вполне понятных слов --- пока познакомимся с технической стороной вопроса.

Ниже код, который строит модель линейной регрессии, которая позволяет пресказывать значение цены бриллиант по его весу. Скопируйте код и выполните его. В окружении должен создаться объект `fit`.

```{r, echo=TRUE}
fit <- lm(price ~ carat, diamonds)
```

`fit` представляет собой список, в котором есть вектор `fitted.values`, который содержит значения, предсказанные моделью.

Постройте диаграмму рассеяния по переменным `carat` и `price` и добавьте на неё с помощью линии предсказанные моделью значения.

:::

```{r 27}
diamonds %>% 
    ggplot(aes(carat, price)) +
    geom_point() +
    geom_line(aes(y = fit$fitted.values),
              color = "red")
```

::: {#pr5-27-autocheck .autocheck}
::: {#pr5-27-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-27" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-27')">

::: {#pr5-27-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-27-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

### #8 {#pr5-28}

<img id="pr5-28-level" class="level"/>

::: {#pr5-28-task .task}

Еще один тип графика, который может встретиться в работе исследователя --- это Line Plot. Есть [данные](https://raw.githubusercontent.com/angelgardt/wlm2023/master/data/pr5/pr5-28.csv) о средней продолжительности просмотра лекций данного курса на 14/12/2023.

Визуализируйте динамику изменения средней продолжительности просмотра по дням с начала курса до 13/12/2023.

:::

```{r 28}
lecs <- read_csv("https://raw.githubusercontent.com/angelgardt/wlm2023/master/data/pr5/pr5-28.csv")

lecs %>% 
  ggplot(aes(day, averageViewDuration, color = code)) +
  geom_line() +
  theme(legend.position = "bottom")
```

::: {#pr5-28-autocheck .autocheck}
::: {#pr5-28-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-28" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-28')">

::: {#pr5-28-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-28-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

### #9 {#pr5-29}

<img id="pr5-29-level" class="level"/>

::: {#pr5-29-task .task}

Если на графике случает что-то интересное, будет полезно подсветить это событие. Так, на графике выше мы видим яркий пик роста средней продолжительности просмотра лекции L2.2 7/12/2023. Давайте это обозначим.

Подпишите пик датой, когда он произошел.

:::

```{r 29}
lecs %>%
  ggplot(aes(day, averageViewDuration, color = code)) +
  geom_line() +
  annotate(
    x = as_date("2023-12-07"),
    y = 4511,
    geom = "text",
    label = "7/12/2023"
  ) +
  theme(legend.position = "bottom")
```

::: {#pr5-29-autocheck .autocheck}
::: {#pr5-29-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-29" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-29')">

::: {#pr5-29-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="pr5-29-hints">

<summary>Подсказка</summary>

`annotate()`

</details>
:::

### #10 {#pr5-30}

<img id="pr5-30-level" class="level"/>

::: {#pr5-30-task .task}

Подсветить интересные события на графике можно не только с помощью подписей, но и выделив область, на которую попало интересное событие. Мы видим, что для L1.1 27/11/2023 случился резкий рост глубины просмотра --- давайте это выделим красным прямоугольником.

Добавьте слой, на котором будет отображен полупрозрачный прямоугольник, который будет выделять пик роста средней продолжительности просмотра 27/11/2023.

:::

```{r 30}
lecs %>%
  ggplot(aes(day, averageViewDuration, color = code)) +
  geom_line() +
  annotate(
    xmin = as_date("2023-11-26"),
    xmax = as_date("2023-11-28"),
    ymin = 3100,
    ymax = 3700,
    geom = "rect",
    fill = "red",
    alpha = 0.3
  ) +
  annotate(
    x = as_date("2023-12-07"),
    y = 4511,
    geom = "text",
    label = "7/12/2023") +
  theme(legend.position = "bottom")
```

::: {#pr5-30-autocheck .autocheck}
::: {#pr5-30-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="pr5-30" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('pr5-30')">

::: {#pr5-30-fb .autocheck-feedback}
:::
:::

::: {.hints-wrapper hidden="true"}
<details class="hints" id="pr5-30-hints">

<summary>Подсказки</summary>

<details class="hint">

<summary>Как делать задание?</summary>

</details>

<details class="hint">

<summary>Что надо сделать?</summary>

</details>

<details class="hint">

<summary>Ответ неверный</summary>

</details>

</details>
:::

```{=html}
<!--- CHANGE pr5 TO pr<n> IN THE LINES BELOW--->
<script type="text/javascript" src="./js/pr5.json"></script>
<script type="text/javascript" src="./js/pr.js"></script>
```
