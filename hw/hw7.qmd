# HW7 // Оценивание параметров в практике статистического анализа. Тестирование статистических гипотез {#hw7 .unnumbered}

```{=html}
<!--
REPLACE ALL hw7 TO hw<n> WITH MATCH CASE
-->
```
## Основные задания {#hw7_main}

```{r opts, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = FALSE, message = FALSE, warning = FALSE)
```

```{r pkgs, eval=TRUE}
library(tidyverse)
theme_set(theme_bw())
```

### #1

<img id="hw7-1-level" class="level"/>

::: {#hw7-1-task .task}

Нам вновь потребуются сгенерированные данные.

Сгенерируйте 1000 независимых выборок по 100 наблюдений из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (`rchisq()`) с параметром 3 (`df = 3`) --- $X \sim \chi^2(3)$.

В качестве зерна датчика случайных чисел используйте 333 (`set.seed(333)`).

```{r, eval=TRUE}
ggplot() +
  geom_function(fun = dchisq, args = list(df = 3)) +
  xlim(0, 10) +
  labs(x = "Value", y = "Density",
       title = "Chi-squared Distribution (df = 3)")
```

:::

```{r}
set.seed(333)
sim1 <- matrix(rchisq(1000 * 100, 3), ncol = 1000)
```

::: {#hw7-1-autocheck .autocheck hidden="true"}
::: {#hw7-1-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-1" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-1')">

::: {#hw7-1-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-1-hints">

<summary>Подсказки</summary>

* Требуется сгенерировать матрицу, размером 100×1000, в каждой колонке которой будут содержаться наблюдения одной выборки.
* Так как выборки независимы, сгенерировать 1000 выборок по 100 наблюдений это то же самое, что сгенерировать одну большую выборку из 100 000 наблюдений, а затем сложить в матрицу по колонкам.
* Сгенерировать выборку поможет функция `rchisq()`, которая работает аналогично хорошо знакомой `rnorm()`, только принимает в себя один параметр `df` (помимо количества наблюдений, которые нужно сгенерировать).
* По заданию `df = 3`, именно такое значение параметра и нужно передать в функцию.
* Сложить сгенерированный вектор в матрицу поможет функция `matrix()`.

</details>
:::

### #2

<img id="hw7-2-level" class="level"/>

::: {#hw7-2-task .task}

На практике мы посмотрели, что центральная предельная теорема (ЦПТ) выполняется в случае с симметричным распределением, а именно с нормальным. Однако сама по себе ЦПТ не оговаривает какие-либо специальные требования к форме исходного распределения. Покажите с помощью симуляции, что распределение выборочных средних большого числа ассиметричных случайных величин будет стремиться к нормальному распределению.

Используйте матрицу `sim1`.

:::

```{r}
sim1 %>% 
  apply(2, mean) %>% 
  tibble(x = .) %>% 
  ggplot(aes(x)) +
  geom_histogram()
```

::: {#hw7-2-autocheck .autocheck hidden="true"}
::: {#hw7-2-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-2" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-2')">

::: {#hw7-2-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-2-hints">

<summary>Подсказки</summary>

* Сгенерированная в предыдущем задании матрица содержит 1000 выборок, на каждой из которых необходимо рассчитать среднее значение.
* Для того, чтобы выполнить какую-либо функцию на каждой из колонок, можно воспользоваться функцией `apply()`.
* Функция `apply()` вернет вектор из средних значений, который дальше необходимо визуализировать средствами пакета `ggplot2`.

</details>
:::

### #3

<img id="hw7-3-level" class="level"/>

::: {#hw7-3-task .task}

Мы также увидели на практике, что среднее арифметическое является несмещенной оценкой математического ожидания. Ну, в какой-то мере это был ожидаемый результат --- распределение всё-таки у нас было симметричное. Не вполне ясно, будет ли сохранться несмещенность оценки, если наше распределение в генеральной совокупности теперь асимметрично.

Проверьте, является ли среднее арифметическое несмещенной оценкой математического ожидания в случае асимметричного распределения. Математическое ожидание распределения $\chi^2(3)$ равно 3: $\mathbb E \big( \chi^2(3) \big) = 3$. Используйте матрицу `sim1`.

Сделайте вывод о (не)смещенности оценки.

:::

```{r}
sim1 %>% 
  apply(2, mean) %>% 
  tibble(x = .) %>% 
  ggplot(aes(x)) +
  geom_histogram() +
  geom_vline(xintercept = 3, color = "red") +
  geom_vline(aes(xintercept = mean(x)))
```

::: {#hw7-3-autocheck .autocheck hidden="true"}
::: {#hw7-3-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-3" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-3')">

::: {#hw7-3-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-3-hints">

<summary>Подсказки</summary>

* За основу возьмите график из предыдущего задания --- ровно он нам и нужен.
* На график необходимо добавить две линии: одна будет обозначать генеральное среднее, другая --- среднее выборочных средних.
* Обе линии визализируются с помощью `geom_vline()`, однако в первом случае функция `aes()` не используется, а во втором --- используется, так как среднее средних рассчитается на основе данных.
* Генеральное среднее в случае распределение хи-квадрат будет совпадать с параметром `df`.
* Если линии находятся близко друг к другу, то оценку можно считать несмещенной. Если оценка значительно отклоняется от параметра генеральной совокупности, то оценка является смещенной.

</details>
:::

### #4

<img id="hw7-4-level" class="level"/>

::: {#hw7-4-task .task}

Вопрос про состоятельность также возникает в случае асимметричного распределения. Потребуется другая структура данных, чтобы проверить сохранение этого свойства оценки.

Сгенерируйте 1000 выборок, объемом от 1 до 1000 наблюдений, из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (`rchisq()`) с параметром 3 (`df = 3`) --- $X \sim \chi^2(3)$. Результаты генерации сохраните в список `sim2`.

:::

```{r}
set.seed(555)
sim2 <- list()

for (i in 1:1000) {
  sim2[[i]] <- rchisq(i, 3)
}

```

::: {#hw7-4-autocheck .autocheck hidden="true"}
::: {#hw7-4-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-4" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-4')">

::: {#hw7-4-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-4-hints">

<summary>Подсказки</summary>

* В случае проверки оценки на состоятельность необходимы выборки разного объема, поэтому сложить их в матрицу будет сложнее --- проще использовать список.
* Создайте пустой список `sim2`, а затем с помощью цикла сложите в него выборки, объемом от 1 до 1000 наблюдений, из того же распределения, что и в первом задании.
* В функции `rchisq()` один из параметров теперь будет меняться --- в качестве этого параметра необходимо передать итератор (обычно `i`) из условия цикла.

</details>
:::

### #5

<img id="hw7-5-level" class="level"/>

::: {#hw7-5-task .task}

На сгенерированных в предыдущем задании данных проверьте, является ли выборочная дисперсия `s^2` (`var()`) состоятельной оценкой дисперсии генеральной совокупности в случае асимметричного распределения. Дисперсия распределения $\chi^2(3)$ равна 6 --- $\mathbb D \big( \chi^2 (3) \big) = 6$.

:::

```{r}
sim2 %>% 
  map(var) %>% 
  unlist() %>% 
  tibble(x = 1:1000,
         y = .) %>% 
  ggplot(aes(x, y)) +
  geom_line() +
  geom_hline(yintercept = 2 * 3, color = "red")
```

::: {#hw7-5-autocheck .autocheck hidden="true"}
::: {#hw7-5-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-5" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-5')">

::: {#hw7-5-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-5-hints">

<summary>Подсказки</summary>

* На каждом элементе списка `sim2` необходимо рассчитать дисперсию с помощью функции `var()`.
* Прогнать функцию по всем элементам списка поможет функция `map()`.
* Результатом функции `map()` является список, который необходимо прекратить в вектор, чтобы с ним дальше было удобно работать на визуализации. Здесь пригодится функция `unlist()`.
* При построении визуализации нужно отобразить, как меняется оценка дисперсии с ростом выборки, а также добавить горзионтальную линию, обозначающую дисперсию генеральной совокупности, чтобы из графика было видно, куда сходится оценка.
* Дисперсия генеральной совокупности в случае распределения хи-квадрат равна $2 \times \text{df}$, то есть в нашем случае 6.

</details>
:::

### #6 {#hw7-6-title}

<img id="hw7-6-level" class="level"/>

::: {#hw7-6-task .task}

Напишите функцию `ci` для вычисления 90% доверительного интервала для среднего. Считайте, что мы работем с выборокой большого объема (порядка 100 наблюдений).

Пороговыми значениями стандартного нормального распределения считайте следующие: $z_{0.05} = -1.64$, $z_{0.95} = 1.64$.

:::

```{r}
ci <- function(x) {se <- sd(x) / sqrt(length(x)); return(c(lower = mean(x) - 1.64 * se, 
                                                           mean = mean(x), 
                                                           upper = mean(x) + 1.64 * se))}
ci(sim1[, 1]) %>% round(2)
```

::: {#hw7-6-autocheck .autocheck}
::: {#hw7-6-ir .input-requirements}
Для самопроверки в поле ответа введите доверительный интервал для среднего первой выборки из симуляции `sim1` в формате `lower,upper`. Значения округлите _до сотых_. Проверка игнорирует все пробелы.
:::

<input class="autocheck-input" type="text" id="hw7-6" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-6')">

::: {#hw7-6-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-6-hints">

<summary>Подсказки</summary>

* Логика расчета границ доверительного интервала всегда одна и та же --- $[\text{se}_X \cdot z_q + \bar X, \text{se}_X \cdot z_{1-q} + \bar X]$.
* Если в случае 95% доверительного интервала $z_q = -1.96$, а $z_{1-q} = 1.96$, то в случае 90% доверительного интервала --- $z_q = -1.64$, а $z_{1-q} = 1.64$.
* Таким образом, можно просто изменить значения, умножаемые на стандартрую ошибку, в коде из практики.
* Если в самопроверке ответ неверный, то проверьте округление (должно быть до сотых) и формат ввода (значения разделяются запятой, десятичный разделитель --- точка).

</details>
:::

### #7

<img id="hw7-7-level" class="level"/>

::: {#hw7-7-task .task}

a. Постройте визуализацию, выражающую статистически корректную интерпретацию 90% доверительного интервала для среднего. Используйте матрицу `sim1`.
a. Рассчитайте долю доверительных интервалов симуляции `sim1`, в границы которых попало значение параметра генеральной совокупности.

:::

```{r}
sim1 %>% 
  apply(2, ci) %>% 
  t() %>% 
  as_tibble() %>% 
  mutate(sample = 1:1000,
         contains = ifelse(3 > lower & 3 < upper, TRUE, FALSE)) # %>% pull(contains) %>% mean()
  ggplot(aes(x = sample,
             y = mean,
             ymin = lower,
             ymax = upper,
             color = contains)) +
  geom_pointrange() +
  geom_hline(yintercept = 3) +
  coord_flip()
```

::: {#hw7-7-autocheck .autocheck}
::: {#hw7-7-ir .input-requirements}
Для самопроверки в поле ответа введите значение, получившееся в пункте _b_. Значение округлите до _тысячных_. В качестве десятичного разделителя используйте точку.
:::

<input class="autocheck-input" type="text" id="hw7-7" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-7')">

::: {#hw7-7-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-7-hints">

<summary>Подсказки</summary>

* Чтобы визуализировать статистически корректную интерпретацию доверительного интервала, необходимо отобразить все доверительные интервалы, полученные в симуляции (1000 штук), и генеральное среднее (удобнее всего в виде линии).
* Цветом необходимо обозначить, попало ли генеральное среднее в конкретный доверительный интервал, или нет. Для этого в данных нужно создать колонку (например, логического типа), в которой для каждого доверительного интервала будет указано, принадлежит ли ему значение среднего генеральной совокупности, или не принадлежит.
* По этой колонке можно рассчитать и долю доверительных интервалов, содержащих генеральное среднее, с помощью функции `mean()` (если колонка была типа `logical`).
* Сами данные для визуализации получаются применением функции `ci`, созданной в предыдущем задании, к матрице `sim1` с помощью функции `apply()`.
* Результатом работы функции `apply()` будет матрица 3×1000, которую необходимо привести к датафрейму (тибблу), предварительно транспонировав фунцией `t()` --- так будет удобнее с ней работать.
* Также для удобства визуализации можно создать в получившемся тиббле колонку с номером выборки в симуляции.
* Если в самопроверке ответ неверный, то проверьте округление (должно быть до тысячных) и формат ввода (десятичный разделитель --- точка).

</details>
:::

### #8

<img id="hw7-8-level" class="level"/>

::: {#hw7-8-task .task}

a. Постройте визуализацию, показывающую графически смысл _capture percentage_. Считайте, что мы работаем с 1000-ой выборкой из симуляции `sim1` --- capture percentage именно для этого доверительного интервала нас интересует.
a. Рассчитайте capture percentage для этого доверительного интервала.

:::

```{r}
sim1 %>% 
  apply(2, ci) %>% 
  t() %>% 
  as_tibble() %>% 
  mutate(sample = 1:1000,
         capture = ifelse(mean > lower[1000] & mean < upper[1000], TRUE, FALSE)) %>% 
  ggplot(aes(x = sample,
             y = mean,
             ymin = lower,
             ymax = upper,
             color = capture)) +
  geom_pointrange() +
  geom_hline(yintercept = 3) +
  coord_flip()
```

::: {#hw7-8-autocheck .autocheck}
::: {#hw7-8-ir .input-requirements}
Для самопроверки в поле ответа введите значение, получившееся в пункте _b_. Значение округлите до _тысячных_. В качестве десятичного разделителя используйте точку.
:::

<input class="autocheck-input" type="text" id="hw7-8" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-8')">

::: {#hw7-8-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-8-hints">

<summary>Подсказки</summary>

* Чтобы визуализировать capture percentage, аналогично предыдущему заданию, необходимо отобразить все доверительные интервалы, полученные в симуляции (1000 штук). Генеральное среднее также можно отобразить (удобнее всего в виде линии).
* Цветом необходимо обозначить те средние (с доверительными интервалами), которые попали в доверительный интервал для какого-либо отдельного среднего.
* АНалогично предыдущему заданию, необходимо создать колонку в данных визуализации. По заданию мы работаем с доверительным интервалом 1000-ой выборки симуляции, поэтому при создании колонки (например, логического типа) необходимо проверить, попадают ли средние все выборок в доверительных интервал среднего 1000-ой выборки.
* По этой колонке можно рассчитать и capture percentage рассматриваемого доверительного интервала, с помощью функции `mean()` (если колонка была типа `logical`).
* Сами данные для визуализации получаются применением функции `ci`, созданной в предыдущем задании, к матрице `sim1` с помощью функции `apply()`, то есть абсолютно аналогично предыдущему заданию.
* Результатом работы функции `apply()` будет матрица 3×1000, которую необходимо привести к датафрейму (тибблу), предварительно транспонировав фунцией `t()` --- так будет удобнее с ней работать.
* Также для удобства визуализации можно создать в получившемся тиббле колонку с номером выборки в симуляции.
* Если в самопроверке ответ неверный, то проверьте округление (должно быть до тысячных) и формат ввода (десятичный разделитель --- точка).

</details>
:::

### #9

<img id="hw7-9-level" class="level"/>

::: {#hw7-9-task .task}

Согласно формуле расчета стандартной ошибки среднего $\text{se}_X = \frac{\text{sd}_X}{\sqrt{n}}$, стандартная ошибка должна уменьшаться с ростом объема выборки. Соответственно, границы доверительных интервалов также должны становиться более узкими.

Используя симуляцию `sim2` покажите графически, что:

a. стандартная ошибка среднего уменьшается с ростом объема выборки
a. доверительные интервалы становятся более узкими с ростом объема выборки

_Для расчета доверительного интервала используйте функцию `ci`, написанную в [задании 6](#hw7-6-title). Для визуализации доверительных интервало в этом задании лучше подойдет `geom_errorbar()`._

:::

```{r}
sim2 %>% 
  map(function(x) sd(x)/sqrt(length(x))) %>% 
  unlist() %>% 
  tibble(x = 1:1000,
         y = .) %>% 
  ggplot(aes(x = x,
             y = y)) +
  geom_point()

sim2 %>% 
  map(ci) %>% 
  as_tibble(.name_repair = "minimal") %>% 
  set_names(1:1000) %>% 
  mutate(a = c("lower", "mean", "upper")) %>% 
  pivot_longer(cols = -a) %>% 
  pivot_wider(names_from = a, values_from = value) %>% 
  mutate(name = as.numeric(name)) %>% 
  ggplot(aes(x = name,
             y = mean,
             ymin = lower,
             ymax = upper)) +
  geom_errorbar()
```

::: {#hw7-9-autocheck .autocheck hidden="true"}
::: {#hw7-9-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-9" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-9')">

::: {#hw7-9-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-9-hints">

<summary>Подсказки</summary>

* Чтобы отобразить искомые закономерности, нам необходимо построить графики, на которых по оси `x` будет располагаться объем выборки (он же будет её порядковым номером --- такова структура списка `sim2`), а по оси `y` --- стандартная ошибка или доверительный интервал.
* Аналогично симуляции для проверки состоятельности оценки, необходимо выполнить функции `se()` и `ci()` соответственно на элементах списка `sim2`. Вновь пригодится функция `map()`.
* В случае с функцией `se()` можно написать такую функцию отдельно, а можно воспользоваться анонимными функциями.
* Результат работы функции `map()` необходимо преобразовать к датафрейму (тибблу) --- это будет данными для визуализации.
* Далее построить соответствующие графики --- для стандартной ошибки подойдет `geom_point()`, а для доверительных интервалов --- `geom_errorbar()`, так как он не отображает среднее и визуализация будет менее нагружена.

</details>
:::

### #10

<img id="hw7-10-level" class="level"/>

::: {#hw7-10-task .task}

Согласно всё той же формуле расчета стандартной ошибки среднего $\text{se}_X = \frac{\text{sd}_X}{\sqrt{n}}$, она должна расти с увеличением дисперсии. Соответственно, границы доверительных интервалов также должны становиться более широкими.

a. Сгенерируйте 200 выборок по 100 наблюдений из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (`rchisq(n, df = k)`) $X \sim \chi^2(k)$, а параметр $k$ меняется от 1 до 200. Сохраните результаты в список `sim3`. В качестве зерна датчика случайных чисел используйте значение 555 (`set.seed(555)`).

Используя полученную симуляцию `sim3` покажите графически, что:


b. стандартная ошибка растет с увеличением дисперсии выборки
c. доверительные интервалы становятся более широкими с увеличением дисперсии выборки

_Для расчета доверительного интервала используйте функцию `ci`, написанную в [задании 6](#hw7-6-title). Для визуализации доверительных интервало в этом задании лучше подойдет `geom_errorbar()`._

:::

```{r}

set.seed(555)
sim3 <- list()

for (i in 1:200) {
  sim3[[i]] <- rchisq(100, i)
}


sim3 %>% 
  map(function(x) sd(x)/sqrt(length(x))) %>% 
  unlist() %>% 
  tibble(x = 1:200,
         y = .) %>% 
  ggplot(aes(x = x,
             y = y)) +
  geom_point()

sim3 %>% 
  map(ci) %>% 
  as_tibble(.name_repair = "minimal") %>% 
  set_names(1:200) %>% 
  mutate(a = c("lower", "mean", "upper")) %>% 
  pivot_longer(cols = -a) %>% 
  pivot_wider(names_from = a, values_from = value) %>% 
  mutate(name = as.numeric(name)) %>% 
  ggplot(aes(x = name,
             y = mean,
             ymin = lower,
             ymax = upper)) +
  geom_errorbar()

```

::: {#hw7-10-autocheck .autocheck hidden="true"}
::: {#hw7-10-ir .input-requirements}
Описание формата инпута.
:::

<input class="autocheck-input" type="text" id="hw7-10" placeholder="Введите ответ…">

<input class="autocheck-button" type="button" value="Проверить" onclick="check('hw7-10')">

::: {#hw7-10-fb .autocheck-feedback}
:::
:::

::: hints-wrapper
<details class="hints" id="hw7-10-hints">

<summary>Подсказки</summary>

* Чтобы отобразить искомые закономерности, нам необходимо построить графики, на которых по оси `x` будет располагаться значение параметра распределения хи-квадрат (он же будет её порядковым номером, а также будет связан с дисперсией --- таково устройство распределения хи-квадрат), а по оси `y` --- стандартная ошибка или доверительный интервал.
* Симуляция `sim3` для этого задания создается аналогично симуляции `sim2`, только теперь варьироваться будет не количество наблюдений, а параметр распределения (`df`) --- именно ему нужно передать итератора (обычно `i`) из условия цикла.
* Далее необходимо выполнить функции `se()` и `ci()` соответственно на элементах списка `sim3`. Вновь пригодится функция `map()`.
* В случае с функцией `se()` можно написать такую функцию отдельно, а можно воспользоваться анонимными функциями.
* Результат работы функции `map()` необходимо преобразовать к датафрейму (тибблу) аналогично предыдущему заданию --- это будет данными для визуализации.
* Далее построить соответствующие графики --- для стандартной ошибки подойдет `geom_point()`, а для доверительных интервалов --- `geom_errorbar()`, так как он не отображает среднее и визуализация будет менее нагружена.

</details>
:::


```{=html}
<!--- CHANGE hw7 TO hw<n> IN THE LINES BELOW--->
<script type="text/javascript" src="./js/hw7.json"></script>
<script type="text/javascript" src="./js/hw.js"></script>
```
