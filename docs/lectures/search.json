[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WLM 2023",
    "section": "",
    "text": "Вступление"
  },
  {
    "objectID": "l1.html#установка-r-и-rstudio",
    "href": "l1.html#установка-r-и-rstudio",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.1 Установка R и RStudio",
    "text": "1.1 Установка R и RStudio\nЧтобы стать счастливым пользователем R, надо установить на свой комп две программы:\n\nсобственно R\n\nна Win\nна Mac\nна Linux\n\nIDE RStudio1\n\nПричем во избежание возможных проблем, надо поставить программы именно в этом порядке — сначала R, а потом RStudio, иначе IDE может на найти R и будет ругаться."
  },
  {
    "objectID": "l1.html#r-как-язык-программирования.-команды",
    "href": "l1.html#r-как-язык-программирования.-команды",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.2 R как язык программирования. Команды",
    "text": "1.2 R как язык программирования. Команды\nВ R нет команд и практически нет ключевых слов, распространенных в других языках программирования. Практически все операции обернуты в функции. Остаются только математические и логические операторы, которые, на самом деле, тоже функции.\n\n1.2.1 Математические операции\nВсе в наличии:\n\n2 + 3 # сложение\n\n[1] 5\n\n4 - 1 # вычитание\n\n[1] 3\n\n5 * 12 # умножение\n\n[1] 60\n\n5 ^ 8 # возведение в степень\n\n[1] 390625\n\n4 / 7 # деление\n\n[1] 0.5714286\n\n5 %/% 3 # целочисленное деление\n\n[1] 1\n\n5 %% 3 # остаток от деления\n\n[1] 2\n\n\nСкобки также существуют и привычно работают:\n\n6 / 3 + 2 * 4\n\n[1] 10\n\n6 / (3 + 2) * 4\n\n[1] 4.8\n\n6 / ((3 + 2) * 4)\n\n[1] 0.3\n\n\n\n\n1.2.2 Математические функции\nМожно посчитать корень:\n\nsqrt(16)\n\n[1] 4\n\n\nИли логарифм:\n\nlog(10)\n\n[1] 2.302585\n\nlog(8, base = 2)\n\n[1] 3\n\nlog(8, 2)\n\n[1] 3\n\n\nИли что-то на тригонометрическом:\n\nsin(5); cos(5); tan(5)\n\n[1] -0.9589243\n\n\n[1] 0.2836622\n\n\n[1] -3.380515\n\n\nКстати, можно и вот так — это к тому, что математические операторы тоже являются функциями:\n\n`+`(2, 3)\n\n[1] 5\n\n`^`(4, 5)\n\n[1] 1024\n\n`/`(8, 3)\n\n[1] 2.666667\n\n\n\n\n1.2.3 Логические операции\nК логическим операциями можно отнести операции сравнения:\n\n5 &gt; 4 # больше\n\n[1] TRUE\n\n6 &lt; 2 # меньше\n\n[1] FALSE\n\n5 &gt;= 5 # больше или равно\n\n[1] TRUE\n\n6 &lt;= 3 # меньше или равно\n\n[1] FALSE\n\n23 == 14 # равно\n\n[1] FALSE\n\n77 != 98 # не равно\n\n[1] TRUE\n\n\nА также логические операторы И (&) и ИЛИ (|):\n\nTRUE & TRUE\n\n[1] TRUE\n\nTRUE & FALSE\n\n[1] FALSE\n\nFALSE & FALSE\n\n[1] FALSE\n\nTRUE | TRUE\n\n[1] TRUE\n\nTRUE | FALSE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\n\n\n\n1.2.4 Переменные и объекты\nРезультаты вычислений и преобразований хотелось бы сохранять, поэтому в R существует оператор присваивания &lt;-:\n\nx &lt;- 5\ny &lt;- 4 * 8\n\nМожно, конечно, написать и x = 5, но сообщество вас не поймет и будет косо смотреть… Когда мы присвоим некоторой переменной какой-либо объект, он отобразиться в окошке Environment, и с ним можно будет работать. Например, совершать разные операции:\n\nx + y\n\n[1] 37\n\nsqrt(x)\n\n[1] 2.236068\n\nlog(y, base = x)\n\n[1] 2.153383\n\n\nОбъектом в R может быть вообще все, что угодно — число, строка, вектор, матрица, датафрейм, таблица, результат моделирования, функция и т.д."
  },
  {
    "objectID": "l1.html#типы-данных",
    "href": "l1.html#типы-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.3 Типы данных",
    "text": "1.3 Типы данных\nТип данных — это характеристика данных, которая определяет:\n\nмножество допустимых значений, которые могут принимать данные этого типа\nдопустимые операции над данными этого типа\n\n\n1.3.1 numeric\nЭто числа с десятичной частью.\n\nclass(3.14)\n\n[1] \"numeric\"\n\ntypeof(3.14)\n\n[1] \"double\"\n\n\n\"double\" нам говорит о том, что числа с десятичной частью храняться в R с двойной точностью. И это хорошо.\n\n\n1.3.2 integer\nЭто целые числа.\n\nclass(3)\n\n[1] \"numeric\"\n\n\nПравда чтобы создать именно целое число, надо указать, что мы хотим именно целое число с помощью литерала L:\n\nclass(3L)\n\n[1] \"integer\"\n\ntypeof(3L)\n\n[1] \"integer\"\n\n\nПо умолчанию объект типа 3 воспринимается R как 3.0, поэтому тип данных будет numeric.\n\n\n1.3.3 complex\nКомплексные числа тоже существуют, но я даже не знаю, когда вам придется их использовать.\n\nclass(2+3i)\n\n[1] \"complex\"\n\n\n\n\n1.3.4 character\nТекст тоже надо как-то хранить.\n\ns1 &lt;- 'a'\ns2 &lt;- \"это строка\"\n\nclass(s1)\n\n[1] \"character\"\n\nclass(s2)\n\n[1] \"character\"\n\n\nКавычки не важны, если у вас не встречаются кавычки внутри кавычек. Тогда надо использовать разные:\n\ns &lt;- 'Мужчина громко зашёл в комнату и высказал решительное \"здравствуйте\"'\ns\n\n[1] \"Мужчина громко зашёл в комнату и высказал решительное \\\"здравствуйте\\\"\"\n\n\n\n\n1.3.5 factor\nБывают такие переменные, которые группируют наши данные. Например,\n\nгород проживания (Москва, Санкт-Петербург, Казань, Екатеринбург)\nуровень образования (бакалавриат, специалитет, магистратура, аспирантура)\nэкспериментальная группа (group1, group2, control)\nи др.\n\nОбычно они текстовые. Для них был придуман тип данных factor, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.\nOrdered factor (упорядоченный фактор) — тип данных, который позволяет задать порядок групп. Например,\n\nуровень образования: bachelor &lt; master &lt; phd &lt; postdoc\nсложность экспериментальной задачи: easy &lt; medium &lt; hard\nи др.\n\nВот упорядоченный фактор нам время от времени может понадобиться — например, для создания визуалиация или в некоторых статистических моделях.\n\n\n1.3.6 Специальные литералы\n\n1.3.6.1 NA\nПропущенное значение (Not Available). Обозначает отсутствие значения там, где оно вроде бы должно быть. Причины могут быть разные:\n\nтехнические ошибки записи данных\nошибки настройки платформы — забыли сделать ответы обязательными\nорганизация исследования — ограничили время на ответ\n«честный» пропуск — дали возможность не отвечать на вопрос\nпредобработка данных — специально создали NA, чтобы далее с ними работать\nи др.\n\n\n\n1.3.6.2 NaN\nЭто не число (Not a Number).\n\n0 / 0\n\n[1] NaN\n\n\n\n\n1.3.6.3 NULL\nЭто ничто. Пустота. Используется для задания аргументов функций."
  },
  {
    "objectID": "l1.html#структуры-данных",
    "href": "l1.html#структуры-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.4 Структуры данных",
    "text": "1.4 Структуры данных\nСтруктура данных — это способ и форма объединения однотипных и/или логически связанных данных.\n\n\n\n\nПример данных\n\n\n\n\n1.4.1 Датафрейм\nВоплощение привычной нам «таблицы» в R.\n\n\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\nЭто сложная структура данных. Чтобы понять всю её мощь, необходимо начать с более простых.\n\n\n1.4.2 Векторы\nВектор — это набор чисел.\n\\[\n\\pmatrix{1 & 4 & 36 & -8 & 90.1 & -14.5}\n\\]\nЕсли это утверждение вызывает у вас внутренний протест, давай проследим пусть от направленного отрезка в набору чисел.\nВозьмем направленный отрезок — вектор:\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\nИменно так мы понимали вектор в школе. Договоримся, что все векторы у нас начинаются из точки \\((0, 0)\\):\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\nЕсли теперь у нас все вектора начинаются из начал координат, то мы можем полностью описать вектор только координатами его конца. Поэтому уберем вектор:\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\nТо есть для нас теперь вектор равносилен точке на плоскости. А точка однозначно описывается двумя координатами. Получается, можно просто записать:\n\\[\n\\pmatrix{1 & 2}\n\\]\nПолучается, что это одно и то же:\n\\[\n\\pmatrix{1 & 0.5}, \\quad \\pmatrix{2 & 3}, \\quad \\pmatrix{4.2 & -3.5}\n\\]\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\nТеперь обобщим вектор на более общие случаи:\n\nВектор — это набор некоторого колчиества элементов одного типа.\n\n\nv_num &lt;- c(1, 6, -34, 7.7) # числовой вектор\nv_char &lt;- c(\"Москва\", \"Санкт-Петербург\", \"Нижний Новгород\", \"Пермь\") # текстовый вектор\nv_log &lt;- c(TRUE, FALSE, TRUE, TRUE) # логический вектор\n\n\nclass(v_num)\n\n[1] \"numeric\"\n\nv_num\n\n[1]   1.0   6.0 -34.0   7.7\n\nclass(v_char)\n\n[1] \"character\"\n\nv_char\n\n[1] \"Москва\"          \"Санкт-Петербург\" \"Нижний Новгород\" \"Пермь\"          \n\nclass(v_log)\n\n[1] \"logical\"\n\nv_log\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n1.4.2.1 Индексация векторов\nИз вектора можно вытащить его элемент:\n\nv_char[2] # по номеру\n\n[1] \"Санкт-Петербург\"\n\nv_num[v_num &gt; 5] # по условию\n\n[1] 6.0 7.7\n\n\n\n\n1.4.2.2 Векторизация\nДля того, чтобы выполнить операцию на всем векторе поэлементно, не нужно перебирать его элементы.\n\nvec &lt;- 1:4\nvec - 1\n\n[1] 0 1 2 3\n\nvec^2\n\n[1]  1  4  9 16\n\nsqrt(vec)\n\n[1] 1.000000 1.414214 1.732051 2.000000\n\n\n\n\n1.4.2.3 Recycling\nЕсли мы будем, например, складывать два вектора разной длины, то более короткий зациклится.\n\nvec1 &lt;- 1:10\nvec2 &lt;- 1:2\n\nvec1\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nvec2\n\n[1] 1 2\n\nvec1 + vec2\n\n [1]  2  4  4  6  6  8  8 10 10 12"
  },
  {
    "objectID": "l1.html#собираем-датафрейм",
    "href": "l1.html#собираем-датафрейм",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.8 Собираем датафрейм",
    "text": "1.8 Собираем датафрейм\n\nвозьмем список\nпотребуем, чтобы его элементами были векторы\nпотребуем, чтобы эти векторы были одинаковой длины\nрасположим их «вертикально»\n\n\n\n\n\nСтруктура списка и датафрейма\n\n\n\n\n1.8.1 Индексация датафрейма\nДля примера возьмем датафрейм про бриллианты:\n\ndiam\n\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\nДатафрейм наследует свойства списка и матрицы, что делает его невероятно гибким в обращении и крайне удобным в работе:\n\ndiam$carat # вытащить столбец\n\n[1] 0.23 0.21 0.23 0.29 0.31 0.24\n\ndiam[diam$price &gt; 330, ] # отобрать строки по условию\n\n# A tibble: 3 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n2  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n3  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\ndiam[, c(2:3, 7)] # вытащить столбцы по номерам\n\n# A tibble: 6 × 3\n  cut       color price\n  &lt;ord&gt;     &lt;ord&gt; &lt;int&gt;\n1 Ideal     E       326\n2 Premium   E       326\n3 Good      E       327\n4 Premium   I       334\n5 Good      J       335\n6 Very Good J       336\n\ndiam[1:4, c(\"carat\", \"price\")] # вытащить отдельные строки по номерам и столбцы по названиям\n\n# A tibble: 4 × 2\n  carat price\n  &lt;dbl&gt; &lt;int&gt;\n1  0.23   326\n2  0.21   326\n3  0.23   327\n4  0.29   334"
  },
  {
    "objectID": "l1.html#функции",
    "href": "l1.html#функции",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.9 Функции",
    "text": "1.9 Функции\n\nЕсли какой-либо кусок кода повторяется более трех раз, имеет смысл обернуть его в функцию.\n\nКак стоит понимать функцию?\nФункция — это некий черный ящик, который\n\nпринимает что-либо на вход\nпроделывает с этим какие-либо операции\nи что-то возвращает\n\n\n1.9.1 Синтаксис функции\nСинтаксис создания функции выглядит так:\n\nfunction_name &lt;- function(arguments) {\n    ...\n    body\n    ...\n    return()\n}\n\nЭлементы функции:\n\nимя функции (function_name) — как мы к ней будем обращаться при вызове\nаргументы функции (arguments) — какие значения и объекты она принимает на вход\nтело функции (body) — что она делает с входными объектами\nвозвращаемое значение (return()) — что функция вернет в качестве результата работы\n\nВызов функции:\n\nfunction_name(arguments)\n\n\n\n1.9.2 Пример функции\n\ncot &lt;- function(x) {\n  result &lt;- 1 / tan(x)\n  return(result)\n}\ncot(3)\n\n[1] -7.015253\n\n\nЕсли функция простая, можно не создавать временные объекты:\n\ncot &lt;- function(x) {\n  return(1 / tan(x))\n}\ncot(3)\n\n[1] -7.015253\n\n\nЕсли функция короткая, можно даже не писать return():\n\ncot &lt;- function(x) {\n  1 / tan(x)\n}\ncot(3)\n\n[1] -7.015253\n\n\n\n\n1.9.3 Пример более полезной функции\nОсторожно, большое!\nЭто функция, которая занималась предобработкой данных в реальном проекте. Прикиньте, если бы мы такой кусок кода повторяли для каждого датасета… — жуть!\n\nmr_preproc &lt;- function(d) {\n\n  require(tidyverse)\n  \n  d |&gt; select(\n    # select columns we need\n    \"Индивидуальный_код\",\n    correctAns,\n    base_pic,\n    rotated_pic,\n    resp_MR_easy.keys,\n    resp_MR_easy.corr,\n    resp_MR_easy.rt\n  ) |&gt;\n    drop_na() |&gt; # remove technical NAs (recording artefacts, not missing data)\n    mutate(task = \"MR\",\n           # add task name (mental rotation)\n           level = \"easy\",\n           # add difficulty level\n           trial = 1:16) |&gt; # number trials\n    rename(\n      \"id\" = \"Индивидуальный_код\",\n      # rename columns for handy usage\n      \"key\" = resp_MR_easy.keys,\n      \"is_correct\" = resp_MR_easy.corr,\n      \"rt\" = resp_MR_easy.rt\n    ) -&gt; MR_easy # ready to use\n  \n  \n  d |&gt; select(\n    # select columns we need\n    \"Индивидуальный_код\",\n    correctAns,\n    base_pic,\n    rotated_pic,\n    resp_MR_medium.keys,\n    resp_MR_medium.corr,\n    resp_MR_medium.rt\n  ) |&gt;\n    drop_na() |&gt; # remove technical NAs (recording artefacts, not missing data)\n    mutate(task = \"MR\",\n           # add task name (mental rotation)\n           level = \"medium\",\n           # add difficulty level\n           trial = 1:16) |&gt;  # number trials\n    rename(\n      # rename columns for handy usage\n      \"id\" = \"Индивидуальный_код\",\n      \"key\" = resp_MR_medium.keys,\n      \"is_correct\" = resp_MR_medium.corr,\n      \"rt\" = resp_MR_medium.rt\n    ) -&gt; MR_medium # ready to use\n  \n  \n  \n  d |&gt; select(\n    # select columns we need\n    \"Индивидуальный_код\",\n    correctAns,\n    base_pic,\n    rotated_pic,\n    resp_MR_hard.keys,\n    resp_MR_hard.corr,\n    resp_MR_hard.rt\n  ) |&gt;\n    drop_na() |&gt; # remove technical NAs (recording artefacts, not missing data)\n    mutate(task = \"MR\",\n           # add task name (mental rotation)\n           level = \"hard\",\n           # add difficulty level\n           trial = 1:16) |&gt; # number trials\n    rename(\n      # rename columns for handy usage\n      \"id\" = \"Индивидуальный_код\",\n      \"key\" = resp_MR_hard.keys,\n      \"is_correct\" = resp_MR_hard.corr,\n      \"rt\" = resp_MR_hard.rt\n    ) -&gt; MR_hard # ready to use\n  \n  # bind all conditions of mental rotation task to one tibble\n  \n  bind_rows(MR_easy, MR_medium, MR_hard) -&gt; MR\n  \n  return(MR)\n \n}"
  },
  {
    "objectID": "l1.html#условный-оператор",
    "href": "l1.html#условный-оператор",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.10 Условный оператор",
    "text": "1.10 Условный оператор\nИногда при написании функции может понадобиться обработать какие-то важные случаи.\n\nНапример, в двух запусках сбора данных столбцы были названы по-разному: если это не учесть, код будет ломаться.\n\nДля этого подойдет условный оператор.\n\n1.10.1 Структура условного оператора\n\nif (condition) {\n  ...\n  body\n  ...\n} else {\n  ...\n  body\n  ...\n}\n\n\n\n1.10.2 Пример функции с условным оператором\nДопустим, нам жизненно неободима функция, которая будет определять, является число четным или нечетным, потому что сами мы постоянно путаемся…\nВот она:\n\nodd_even &lt;- function(x) { # функция принимает на вход число\n  \n  if (x %% 2 == 0) { # проверяет, равняется ли нулю остаток от деления числа на два\n    \n    return(\"even\") # возвращает \"even\", если равняется\n    \n  } else {\n    \n    return(\"odd\") # возвращает \"odd\", если нет\n    \n  }\n  \n}\n\n\nodd_even(2)\n\n[1] \"even\"\n\nodd_even(34)\n\n[1] \"even\"\n\nodd_even(11)\n\n[1] \"odd\"\n\nodd_even(135)\n\n[1] \"odd\"\n\n\nРаботает!"
  },
  {
    "objectID": "l1.html#циклы",
    "href": "l1.html#циклы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.13 Циклы",
    "text": "1.13 Циклы\nТо, что мы написали функция, чтобы не дублировать код — это хорошо, однако эту функцию нам все равно придется запускать много раз, если нам надо этот кусок кода повторить.\nПоэтому используем цикл:\n\nfor (i in a:b) {\n  ...\n  body\n  ...\n}"
  },
  {
    "objectID": "l1.html#матрицы",
    "href": "l1.html#матрицы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.5 Матрицы",
    "text": "1.5 Матрицы\nЕсли мы желаем приблизиться к датафрейму, то одного ряда элементов нам недостаточно — надо выходить во второе измерение! Поэтому уложим вектор в матрицу:\n\n\n\n\nВарианты преобразования вектора в матрицу\n\n\n\nИли вот еще разные варианты:\n\nv &lt;- 1:12\nm1 &lt;- matrix(v, nrow = 3)\nm1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nm2 &lt;- matrix(v, nrow = 4)\nm2\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\nm3 &lt;- matrix(v, nrow = 3, byrow = TRUE)\nm3\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nm4 &lt;- matrix(v, nrow = 4, byrow = TRUE)\nm4\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n\n\n1.5.1 Индексация матриц\nИз матрицы можно вытащить её элементы:\n\nm1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nm1[2, 3] # отдельный элемент\n\n[1] 8\n\nm1[1, ] # целую строку\n\n[1]  1  4  7 10\n\nm1[, 4] # целый столбец\n\n[1] 10 11 12\n\nm1[1:2, 2:4] # часть матрицы\n\n     [,1] [,2] [,3]\n[1,]    4    7   10\n[2,]    5    8   11"
  },
  {
    "objectID": "l1.html#массивы",
    "href": "l1.html#массивы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.6 Массивы",
    "text": "1.6 Массивы\n\nВектор — одномерный массив.\nМатрица — двумерный массив.\nМассивы — структуры, которые объединяют данные только одного типа.\n\n\nc(2, TRUE)\n\n[1] 2 1\n\nc(2, TRUE, \"word\")\n\n[1] \"2\"    \"TRUE\" \"word\"\n\n\nПри объединении разных типов данных в одном массиве происходит приведение типов (coercion) по следующей иерархии:\n\nlogical → integer → numeric → complex → character\n\nЭто нам осложняет жизнь, так как мы бы хотели объединять данные разных типов в одну структуру."
  },
  {
    "objectID": "l1.html#списки",
    "href": "l1.html#списки",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.7 Списки",
    "text": "1.7 Списки\nСписки позволяют объединять массивы различных типов данных, чем делают нашу жизнь значительно приятнее.\n\n\n\n\nСхема внутренней структуры списка\n\n\n\nНапример, так:\n\nl &lt;- list(v1 = v_num,\n          v2 = v_char,\n          m1 = m1,\n          ls = list(v = v,\n                    m = m3))\nl\n\n$v1\n[1]   1.0   6.0 -34.0   7.7\n\n$v2\n[1] \"Москва\"          \"Санкт-Петербург\" \"Нижний Новгород\" \"Пермь\"          \n\n$m1\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n$ls\n$ls$v\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n$ls$m\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n\n\n1.7.1 Индексация списков\n\nl[1] # по номеру элемента, возвращается список\n\n$v1\n[1]   1.0   6.0 -34.0   7.7\n\nl[[1]] # по номеру элемента, возвращается массив\n\n[1]   1.0   6.0 -34.0   7.7\n\nl$ls # по названию элемента\n\n$v\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n$m\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nl$ls$m # можно идти многоуровнево\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12"
  },
  {
    "objectID": "l1.html#пример-функции-из-реального-проекта-с-условным-оператором",
    "href": "l1.html#пример-функции-из-реального-проекта-с-условным-оператором",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.11 Пример функции из реального проекта с условным оператором",
    "text": "1.11 Пример функции из реального проекта с условным оператором\n\nms_preproc &lt;- function(d) {\n  \n  require(tidyverse)\n  \n  # Since we our participants could fill the fields in any order, \n  # here is a function which allows us to count correct inputs \n  # our subjects made.\n  \n  if (\"mouse_MSe.time\" %in% colnames(d)) { \n    ### здесь начинается условный оператор, который проверяет, есть ли такая колонка\n    ### если колонка есть, то запускается код ниже\n    \n    d |&gt; select(\n      \"Индивидуальный_код\",\n      matches(\"^noun\"),\n      matches(\"resp\\\\d\\\\.text$\"),\n      \"mouse_MSe.time\"\n    ) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:3)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"easy\") |&gt;\n      rename(\n        \"resp1\" = resp1.text,\n        \"resp2\" = resp2.text,\n        \"resp3\" = resp3.text,\n        \"id\" = \"Индивидуальный_код\",\n        \"rt\" = \"mouse_MSe.time\"\n      ) |&gt;\n      select(-c(paste0(\"noun\", 4:7))) -&gt; MS_easy\n    \n    d |&gt; select(\n      \"Индивидуальный_код\",\n      matches(\"^noun\"),\n      matches(\"MSm.text$\"),\n      \"mouse_MSm.time\"\n    ) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:5)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 6:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"medium\") |&gt; \n      rename(\"id\" = \"Индивидуальный_код\",\n             \"rt\" = \"mouse_MSm.time\") |&gt;\n      rename_with(.fn = str_replace_all, \n                  pattern = \"_MSm\\\\.text\", \n                  replacement = \"\") |&gt; \n      select(-noun6, -noun7) -&gt; MS_medium\n    \n    \n    d |&gt; select(\n      \"Индивидуальный_код\",\n      matches(\"^noun\"),\n      matches(\"MSh.text$\"),\n      \"mouse_MSh.time\"\n    ) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:7)), all_vars(!is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"hard\") |&gt;\n      rename(\"id\" = \"Индивидуальный_код\",\n             \"rt\" = \"mouse_MSh.time\") |&gt; \n      rename_with(.fn = str_replace_all,\n                  pattern = \"_MSh\\\\.text\",\n                  replacement = \"\") -&gt; MS_hard\n    \n  } else {\n    ### а если колонки нет, то запускается этот код\n    \n    d |&gt; select(\"Индивидуальный_код\",\n                matches(\"^noun\"),\n                matches(\"resp\\\\d\\\\.text$\")) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:3)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"easy\",\n             rt = NA) |&gt;\n      rename(\n        \"resp1\" = resp1.text,\n        \"resp2\" = resp2.text,\n        \"resp3\" = resp3.text,\n        \"id\" = \"Индивидуальный_код\"\n      ) |&gt;\n      select(-c(paste0(\"noun\", 4:7))) -&gt; MS_easy\n    \n    d |&gt; select(\"Индивидуальный_код\",\n                matches(\"^noun\"),\n                matches(\"MSm.text$\")) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:5)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 6:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"medium\",\n             rt = NA) |&gt;\n      rename(\"id\" = \"Индивидуальный_код\") |&gt;\n      rename_with(.fn = str_replace_all,\n                  pattern = \"_MSm\\\\.text\",\n                  replacement = \"\") |&gt; \n      select(-noun6, -noun7) -&gt; MS_medium\n    \n    \n    d |&gt; select(\"Индивидуальный_код\",\n                matches(\"^noun\"),\n                matches(\"MSh.text$\")) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:7)), all_vars(!is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"hard\",\n             rt = NA) |&gt;\n      rename(\"id\" = \"Индивидуальный_код\") |&gt; \n      rename_with(.fn = str_replace_all,\n                  pattern = \"_MSh\\\\.text\", \n                  replacement = \"\") -&gt; MS_hard\n  }\n  \n  tibble(\n    id = MS_easy$id[1],\n    trials = 1:16,\n    MS_easy_n = n_count(MS_easy),\n    MS_easy_rt = MS_easy$rt,\n    MS_medium_n = n_count(MS_medium),\n    MS_medium_rt = MS_medium$rt,\n    MS_hard_n = n_count(MS_hard),\n    MS_hard_rt = MS_hard$rt\n  ) |&gt;\n    pivot_longer(cols = -c(\"id\", \"trials\"), values_to = \"value\") |&gt;\n    separate(name, c(\"task\", \"level\", \"name\")) |&gt;\n    pivot_wider(values_from = value, names_from = name) |&gt;\n    mutate(acc = ifelse(level == \"easy\", n / 3,\n                        ifelse(\n                          level == \"medium\", n / 5,\n                          ifelse(level == \"hard\", n / 7, NA)\n                        ))) -&gt; MS\n  \n  return(MS)\n  \n}"
  },
  {
    "objectID": "l1.html#вне-функций",
    "href": "l1.html#вне-функций",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.12 Вне функций",
    "text": "1.12 Вне функций\nВне функций условный оператор практически не используется, потому что для предобработки данных есть удобная функция ifelse()."
  },
  {
    "objectID": "l1.html#пример-простеньких-циклов",
    "href": "l1.html#пример-простеньких-циклов",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.14 Пример простеньких циклов",
    "text": "1.14 Пример простеньких циклов\nПросто печатаем числа от 1 до 10:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nНу, или более сложные выражения:\n\nfor (j in 1:10) {\n  print(sqrt(j) + j^2)\n}\n\n[1] 2\n[1] 5.414214\n[1] 10.73205\n[1] 18\n[1] 27.23607\n[1] 38.44949\n[1] 51.64575\n[1] 66.82843\n[1] 84\n[1] 103.1623"
  },
  {
    "objectID": "l1.html#пример-цикла-для-чтения-и-предоработки-данных",
    "href": "l1.html#пример-цикла-для-чтения-и-предоработки-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.15 Пример цикла для чтения и предоработки данных",
    "text": "1.15 Пример цикла для чтения и предоработки данных\n\nfor (i in 1:length(files)) { ## будем двигаться от 1 до количества файлов в папке с данными\n  \n  print(files[i]) ## печатает имя файла, чтобы видеть на каком файле сломалось, если сломается\n  \n  d &lt;- read_csv(files[i], show_col_types = FALSE) ## считывает один файл из папки\n  \n  ## запускаем функции предобработки\n  MR_data |&gt; bind_rows(mr_preproc(d) |&gt; mutate(file = files[i])) -&gt; MR_data\n  ST_data |&gt; bind_rows(st_preproc(d) |&gt; mutate(file = files[i])) -&gt; ST_data\n  MS_data |&gt; bind_rows(ms_preproc(d) |&gt; mutate(file = files[i])) -&gt; MS_data\n  NASATLX_data |&gt; bind_rows(nasatlx_preproc(d) |&gt; mutate(file = files[i])) -&gt; NASATLX_data\n  SEQUENCE_data |&gt; bind_rows(sequence_preproc(d) |&gt; mutate(file = files[i])) -&gt; SEQUENCE_data\n  \n  ## завершили цикл, идем на следующую итерацию\n\n}"
  },
  {
    "objectID": "l1.html#циклы-в-r-это-зло-они-долго-работают",
    "href": "l1.html#циклы-в-r-это-зло-они-долго-работают",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.16 Циклы в R — это зло! Они долго работают!",
    "text": "1.16 Циклы в R — это зло! Они долго работают!\n\nДа, циклы работает не быстро — это правда. Но, с другой стороны, мы и не терабайты данных анализируем.\n\nДопустим, у нас 50 респондентов. Цикл, подобный тому, что на предыдущем слайде, отбработает секунд за 5. Даже чай не успеете заварить.\nБезусловно, есть более изящные и быстрые инструменты, и с ними мы познакомимся на предобработке данных. Но в целом, можно и циклом обойтись.\nКонечно, если у вас огромные датасеты и вы работаете с Big Data, то прогон цикла может значительно затянуться — в этом случае разумно сразу использовать другие инструменты."
  },
  {
    "objectID": "l1.html#footnotes",
    "href": "l1.html#footnotes",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "",
    "text": "По пути надо ещё не перепутать с R-Studio, которая восстанавливает данные с диска. Критическое сходство названий двух программ обязывает к повышенной внимательности при написании работ/статей/отчётов/заявок на гранты, в которых вы ссылаетесь на RStudio — иногда рецензенты весьма недоумевают, как исследователи анализировали данные с помощью ПО для восстановления данных…↩︎"
  }
]