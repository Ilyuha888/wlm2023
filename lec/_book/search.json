[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "L // WLM 2023",
    "section": "",
    "text": "Вступление",
    "crumbs": [
      "Вступление"
    ]
  },
  {
    "objectID": "l1.html#установка-r-и-rstudio",
    "href": "l1.html#установка-r-и-rstudio",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.1 Установка R и RStudio",
    "text": "1.1 Установка R и RStudio\nЧтобы стать счастливым пользователем R, надо установить на свой комп две программы:\n\nсобственно R\n\nна Win\nна Mac\nна Linux\n\nIDE RStudio1\n\nПричем во избежание возможных проблем, надо поставить программы именно в этом порядке — сначала R, а потом RStudio, иначе IDE может на найти R и будет ругаться.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#r-как-язык-программирования.-команды",
    "href": "l1.html#r-как-язык-программирования.-команды",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.2 R как язык программирования. Команды",
    "text": "1.2 R как язык программирования. Команды\nВ R нет команд и практически нет ключевых слов, распространенных в других языках программирования. Практически все операции обернуты в функции. Остаются только математические и логические операторы, которые, на самом деле, тоже функции.\n\n1.2.1 Математические операции\nВсе в наличии:\n\n2 + 3 # сложение\n\n[1] 5\n\n4 - 1 # вычитание\n\n[1] 3\n\n5 * 12 # умножение\n\n[1] 60\n\n5 ^ 8 # возведение в степень\n\n[1] 390625\n\n4 / 7 # деление\n\n[1] 0.5714286\n\n5 %/% 3 # целочисленное деление\n\n[1] 1\n\n5 %% 3 # остаток от деления\n\n[1] 2\n\n\nСкобки также существуют и привычно работают:\n\n6 / 3 + 2 * 4\n\n[1] 10\n\n6 / (3 + 2) * 4\n\n[1] 4.8\n\n6 / ((3 + 2) * 4)\n\n[1] 0.3\n\n\n\n\n1.2.2 Математические функции\nМожно посчитать корень:\n\nsqrt(16)\n\n[1] 4\n\n\nИли логарифм:\n\nlog(10)\n\n[1] 2.302585\n\nlog(8, base = 2)\n\n[1] 3\n\nlog(8, 2)\n\n[1] 3\n\n\nИли что-то на тригонометрическом:\n\nsin(5); cos(5); tan(5)\n\n[1] -0.9589243\n\n\n[1] 0.2836622\n\n\n[1] -3.380515\n\n\nКстати, можно и вот так — это к тому, что математические операторы тоже являются функциями:\n\n`+`(2, 3)\n\n[1] 5\n\n`^`(4, 5)\n\n[1] 1024\n\n`/`(8, 3)\n\n[1] 2.666667\n\n\n\n\n1.2.3 Логические операции\nК логическим операциями можно отнести операции сравнения:\n\n5 &gt; 4 # больше\n\n[1] TRUE\n\n6 &lt; 2 # меньше\n\n[1] FALSE\n\n5 &gt;= 5 # больше или равно\n\n[1] TRUE\n\n6 &lt;= 3 # меньше или равно\n\n[1] FALSE\n\n23 == 14 # равно\n\n[1] FALSE\n\n77 != 98 # не равно\n\n[1] TRUE\n\n\nА также логические операторы И (&) и ИЛИ (|):\n\nTRUE & TRUE\n\n[1] TRUE\n\nTRUE & FALSE\n\n[1] FALSE\n\nFALSE & FALSE\n\n[1] FALSE\n\nTRUE | TRUE\n\n[1] TRUE\n\nTRUE | FALSE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\n\n\n\n1.2.4 Переменные и объекты\nРезультаты вычислений и преобразований хотелось бы сохранять, поэтому в R существует оператор присваивания &lt;-:\n\nx &lt;- 5\ny &lt;- 4 * 8\n\nМожно, конечно, написать и x = 5, но сообщество вас не поймет и будет косо смотреть… Когда мы присвоим некоторой переменной какой-либо объект, он отобразиться в окошке Environment, и с ним можно будет работать. Например, совершать разные операции:\n\nx + y\n\n[1] 37\n\nsqrt(x)\n\n[1] 2.236068\n\nlog(y, base = x)\n\n[1] 2.153383\n\n\nОбъектом в R может быть вообще все, что угодно — число, строка, вектор, матрица, датафрейм, таблица, результат моделирования, функция и т.д.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#типы-данных",
    "href": "l1.html#типы-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.3 Типы данных",
    "text": "1.3 Типы данных\nТип данных — это характеристика данных, которая определяет:\n\nмножество допустимых значений, которые могут принимать данные этого типа\nдопустимые операции над данными этого типа\n\n\n1.3.1 numeric\nЭто числа с десятичной частью.\n\nclass(3.14)\n\n[1] \"numeric\"\n\ntypeof(3.14)\n\n[1] \"double\"\n\n\n\"double\" нам говорит о том, что числа с десятичной частью храняться в R с двойной точностью. И это хорошо.\n\n\n1.3.2 integer\nЭто целые числа.\n\nclass(3)\n\n[1] \"numeric\"\n\n\nПравда чтобы создать именно целое число, надо указать, что мы хотим именно целое число с помощью литерала L:\n\nclass(3L)\n\n[1] \"integer\"\n\ntypeof(3L)\n\n[1] \"integer\"\n\n\nПо умолчанию объект типа 3 воспринимается R как 3.0, поэтому тип данных будет numeric.\n\n\n1.3.3 complex\nКомплексные числа тоже существуют, и мы с ними немного познакомимся, чтобы перестать их бояться.\n\nclass(2+3i)\n\n[1] \"complex\"\n\n\n\n\n1.3.4 character\nТекст тоже надо как-то хранить.\n\ns1 &lt;- 'a'\ns2 &lt;- \"это строка\"\n\nclass(s1)\n\n[1] \"character\"\n\nclass(s2)\n\n[1] \"character\"\n\n\nКавычки не важны, если у вас не встречаются кавычки внутри кавычек. Тогда надо использовать разные:\n\ns &lt;- 'Мужчина громко зашёл в комнату и высказал решительное \"здравствуйте\"'\ns\n\n[1] \"Мужчина громко зашёл в комнату и высказал решительное \\\"здравствуйте\\\"\"\n\n\n\n\n1.3.5 factor\nБывают такие переменные, которые группируют наши данные. Например,\n\nгород проживания (Москва, Санкт-Петербург, Казань, Екатеринбург)\nуровень образования (бакалавриат, специалитет, магистратура, аспирантура)\nэкспериментальная группа (group1, group2, control)\nи др.\n\nОбычно они текстовые. Для них был придуман тип данных factor, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.\nOrdered factor (упорядоченный фактор) — тип данных, который позволяет задать порядок групп. Например,\n\nуровень образования: bachelor &lt; master &lt; phd &lt; postdoc\nсложность экспериментальной задачи: easy &lt; medium &lt; hard\nи др.\n\nВот упорядоченный фактор нам время от времени может понадобиться — например, для создания визуалиация или в некоторых статистических моделях.\n\n\n1.3.6 Специальные литералы\n\n1.3.6.1 NA\nПропущенное значение (Not Available). Обозначает отсутствие значения там, где оно вроде бы должно быть. Причины могут быть разные:\n\nтехнические ошибки записи данных\nошибки настройки платформы — забыли сделать ответы обязательными\nорганизация исследования — ограничили время на ответ\n«честный» пропуск — дали возможность не отвечать на вопрос\nпредобработка данных — специально создали NA, чтобы далее с ними работать\nи др.\n\n\n\n1.3.6.2 NaN\nЭто не число (Not a Number).\n\n0 / 0\n\n[1] NaN\n\n\n\n\n1.3.6.3 NULL\nЭто ничто. Пустота. Используется для задания аргументов функций.\n\nggplot(data = NULL)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#структуры-данных",
    "href": "l1.html#структуры-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.4 Структуры данных",
    "text": "1.4 Структуры данных\nСтруктура данных — это способ и форма объединения однотипных и/или логически связанных данных.\n\n\n\n\nПример данных\n\n\n\n\n1.4.1 Датафрейм\nВоплощение привычной нам «таблицы» в R.\n\n\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\nЭто сложная структура данных. Чтобы понять всю её мощь, необходимо начать с более простых.\n\n\n1.4.2 Векторы\nВектор — это набор чисел.\n\\[\n\\pmatrix{1 & 4 & 36 & -8 & 90.1 & -14.5}\n\\]\nЕсли это утверждение вызывает у вас внутренний протест, давай проследим пусть от направленного отрезка в набору чисел.\nВозьмем направленный отрезок — вектор:\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\n\n\n\n\nИменно так мы понимали вектор в школе. Договоримся, что все векторы у нас начинаются из точки \\((0, 0)\\):\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\n\n\n\n\nЕсли теперь у нас все вектора начинаются из начал координат, то мы можем полностью описать вектор только координатами его конца. Поэтому уберем вектор:\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\n\n\n\n\nТо есть для нас теперь вектор равносилен точке на плоскости. А точка однозначно описывается двумя координатами. Получается, можно просто записать:\n\\[\n\\pmatrix{1 & 2}\n\\]\nПолучается, что это одно и то же:\n\\[\n\\pmatrix{1 & 0.5}, \\quad \\pmatrix{2 & 3}, \\quad \\pmatrix{4.2 & -3.5}\n\\]\n\n\nWarning in is.na(x): is.na() applied to non-(list or vector) of type\n'expression'\n\n\n\n\n\n\n\n\n\nТеперь обобщим вектор на более общие случаи:\n\nВектор — это набор некоторого колчиества элементов одного типа.\n\n\nv_num &lt;- c(1, 6, -34, 7.7) # числовой вектор\nv_char &lt;- c(\"Москва\", \"Санкт-Петербург\", \"Нижний Новгород\", \"Пермь\") # текстовый вектор\nv_log &lt;- c(TRUE, FALSE, TRUE, TRUE) # логический вектор\n\n\nclass(v_num)\n\n[1] \"numeric\"\n\nv_num\n\n[1]   1.0   6.0 -34.0   7.7\n\nclass(v_char)\n\n[1] \"character\"\n\nv_char\n\n[1] \"Москва\"          \"Санкт-Петербург\" \"Нижний Новгород\" \"Пермь\"          \n\nclass(v_log)\n\n[1] \"logical\"\n\nv_log\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n\n\n1.4.2.1 Индексация векторов\nИз вектора можно вытащить его элемент:\n\nv_char[2] # по номеру\n\n[1] \"Санкт-Петербург\"\n\nv_num[v_num &gt; 5] # по условию\n\n[1] 6.0 7.7\n\n\n\n\n1.4.2.2 Векторизация\nДля того, чтобы выполнить операцию на всем векторе поэлементно, не нужно перебирать его элементы.\n\nvec &lt;- 1:4\nvec - 1\n\n[1] 0 1 2 3\n\nvec^2\n\n[1]  1  4  9 16\n\nsqrt(vec)\n\n[1] 1.000000 1.414214 1.732051 2.000000\n\n\n\n\n1.4.2.3 Recycling\nЕсли мы будем, например, складывать два вектора разной длины, то более короткий зациклится.\n\nvec1 &lt;- 1:10\nvec2 &lt;- 1:2\n\nvec1\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nvec2\n\n[1] 1 2\n\nvec1 + vec2\n\n [1]  2  4  4  6  6  8  8 10 10 12",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#матрицы",
    "href": "l1.html#матрицы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.5 Матрицы",
    "text": "1.5 Матрицы\nЕсли мы желаем приблизиться к датафрейму, то одного ряда элементов нам недостаточно — надо выходить во второе измерение! Поэтому уложим вектор в матрицу:\n\n\n\n\nВарианты преобразования вектора в матрицу\n\n\n\nИли вот еще разные варианты:\n\nv &lt;- 1:12\nm1 &lt;- matrix(v, nrow = 3)\nm1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nm2 &lt;- matrix(v, nrow = 4)\nm2\n\n     [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n\nm3 &lt;- matrix(v, nrow = 3, byrow = TRUE)\nm3\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nm4 &lt;- matrix(v, nrow = 4, byrow = TRUE)\nm4\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n\n\n1.5.1 Индексация матриц\nИз матрицы можно вытащить её элементы:\n\nm1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nm1[2, 3] # отдельный элемент\n\n[1] 8\n\nm1[1, ] # целую строку\n\n[1]  1  4  7 10\n\nm1[, 4] # целый столбец\n\n[1] 10 11 12\n\nm1[1:2, 2:4] # часть матрицы\n\n     [,1] [,2] [,3]\n[1,]    4    7   10\n[2,]    5    8   11",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#массивы",
    "href": "l1.html#массивы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.6 Массивы",
    "text": "1.6 Массивы\n\nВектор — одномерный массив.\nМатрица — двумерный массив.\nМассивы — структуры, которые объединяют данные только одного типа.\n\n\nc(2, TRUE)\n\n[1] 2 1\n\nc(2, TRUE, \"word\")\n\n[1] \"2\"    \"TRUE\" \"word\"\n\n\nПри объединении разных типов данных в одном массиве происходит приведение типов (coercion) по следующей иерархии:\n\nlogical → integer → numeric → complex → character\n\nЭто нам осложняет жизнь, так как мы бы хотели объединять данные разных типов в одну структуру.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#списки",
    "href": "l1.html#списки",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.7 Списки",
    "text": "1.7 Списки\nСписки позволяют объединять массивы различных типов данных, чем делают нашу жизнь значительно приятнее.\n\n\n\n\nСхема внутренней структуры списка\n\n\n\nНапример, так:\n\nl &lt;- list(v1 = v_num,\n          v2 = v_char,\n          m1 = m1,\n          ls = list(v = v,\n                    m = m3))\nl\n\n$v1\n[1]   1.0   6.0 -34.0   7.7\n\n$v2\n[1] \"Москва\"          \"Санкт-Петербург\" \"Нижний Новгород\" \"Пермь\"          \n\n$m1\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n$ls\n$ls$v\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n$ls$m\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\n\n\n1.7.1 Индексация списков\n\nl[1] # по номеру элемента, возвращается список\n\n$v1\n[1]   1.0   6.0 -34.0   7.7\n\nl[[1]] # по номеру элемента, возвращается массив\n\n[1]   1.0   6.0 -34.0   7.7\n\nl$ls # по названию элемента\n\n$v\n [1]  1  2  3  4  5  6  7  8  9 10 11 12\n\n$m\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12\n\nl$ls$m # можно идти многоуровнево\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n[3,]    9   10   11   12",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#собираем-датафрейм",
    "href": "l1.html#собираем-датафрейм",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.8 Собираем датафрейм",
    "text": "1.8 Собираем датафрейм\n\nвозьмем список\nпотребуем, чтобы его элементами были векторы\nпотребуем, чтобы эти векторы были одинаковой длины\nрасположим их «вертикально»\n\n\n\n\n\nСтруктура списка и датафрейма\n\n\n\n\n1.8.1 Индексация датафрейма\nДля примера возьмем датафрейм про бриллианты:\n\ndiam\n\n# A tibble: 6 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\n\nДатафрейм наследует свойства списка и матрицы, что делает его невероятно гибким в обращении и крайне удобным в работе:\n\ndiam$carat # вытащить столбец\n\n[1] 0.23 0.21 0.23 0.29 0.31 0.24\n\ndiam[diam$price &gt; 330, ] # отобрать строки по условию\n\n# A tibble: 3 × 10\n  carat cut       color clarity depth table price     x     y     z\n  &lt;dbl&gt; &lt;ord&gt;     &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n2  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n3  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n\ndiam[, c(2:3, 7)] # вытащить столбцы по номерам\n\n# A tibble: 6 × 3\n  cut       color price\n  &lt;ord&gt;     &lt;ord&gt; &lt;int&gt;\n1 Ideal     E       326\n2 Premium   E       326\n3 Good      E       327\n4 Premium   I       334\n5 Good      J       335\n6 Very Good J       336\n\ndiam[1:4, c(\"carat\", \"price\")] # вытащить отдельные строки по номерам и столбцы по названиям\n\n# A tibble: 4 × 2\n  carat price\n  &lt;dbl&gt; &lt;int&gt;\n1  0.23   326\n2  0.21   326\n3  0.23   327\n4  0.29   334",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#функции",
    "href": "l1.html#функции",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.9 Функции",
    "text": "1.9 Функции\n\nЕсли какой-либо кусок кода повторяется более трех раз, имеет смысл обернуть его в функцию.\n\nКак стоит понимать функцию?\nФункция — это некий черный ящик, который\n\nпринимает что-либо на вход\nпроделывает с этим какие-либо операции\nи что-то возвращает\n\n\n1.9.1 Синтаксис функции\nСинтаксис создания функции выглядит так:\n\nfunction_name &lt;- function(arguments) {\n    ...\n    body\n    ...\n    return()\n}\n\nЭлементы функции:\n\nимя функции (function_name) — как мы к ней будем обращаться при вызове\nаргументы функции (arguments) — какие значения и объекты она принимает на вход\nтело функции (body) — что она делает с входными объектами\nвозвращаемое значение (return()) — что функция вернет в качестве результата работы\n\nВызов функции:\n\nfunction_name(arguments)\n\n\n\n1.9.2 Пример функции\n\ncot &lt;- function(x) {\n  result &lt;- 1 / tan(x)\n  return(result)\n}\ncot(3)\n\n[1] -7.015253\n\n\nЕсли функция простая, можно не создавать временные объекты:\n\ncot &lt;- function(x) {\n  return(1 / tan(x))\n}\ncot(3)\n\n[1] -7.015253\n\n\nЕсли функция короткая, можно даже не писать return():\n\ncot &lt;- function(x) {\n  1 / tan(x)\n}\ncot(3)\n\n[1] -7.015253\n\n\n\n\n1.9.3 Пример более полезной функции\nОсторожно, большое!\nЭто функция, которая занималась предобработкой данных в реальном проекте. Прикиньте, если бы мы такой кусок кода повторяли для каждого датасета… — жуть!\n\n\n\n\n\n\nВажно!\n\n\n\nВам не нужно сейчас подробно понимать, что написано ниже — мы все разберем по ходу курса и научимся писать такое же! Сейчас главное ухватить структуру функции — где аргументы, где тело, где возвращаемое значение. Всё! Остальное освоим по ходу дела.\n\n\n\nmr_preproc &lt;- function(d) {\n\n  require(tidyverse)\n  \n  d |&gt; select(\n    # select columns we need\n    \"Индивидуальный_код\",\n    correctAns,\n    base_pic,\n    rotated_pic,\n    resp_MR_easy.keys,\n    resp_MR_easy.corr,\n    resp_MR_easy.rt\n  ) |&gt;\n    drop_na() |&gt; # remove technical NAs (recording artefacts, not missing data)\n    mutate(task = \"MR\",\n           # add task name (mental rotation)\n           level = \"easy\",\n           # add difficulty level\n           trial = 1:16) |&gt; # number trials\n    rename(\n      \"id\" = \"Индивидуальный_код\",\n      # rename columns for handy usage\n      \"key\" = resp_MR_easy.keys,\n      \"is_correct\" = resp_MR_easy.corr,\n      \"rt\" = resp_MR_easy.rt\n    ) -&gt; MR # ready to use\n  \n  return(MR)\n \n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#условный-оператор",
    "href": "l1.html#условный-оператор",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.10 Условный оператор",
    "text": "1.10 Условный оператор\nИногда при написании функции может понадобиться обработать какие-то важные случаи.\n\nНапример, в двух запусках сбора данных столбцы были названы по-разному: если это не учесть, код будет ломаться.\n\nДля этого подойдет условный оператор.\n\n1.10.1 Структура условного оператора\n\nif (condition) {\n  ...\n  body\n  ...\n} else {\n  ...\n  body\n  ...\n}\n\n\n\n1.10.2 Пример функции с условным оператором\nДопустим, нам жизненно неободима функция, которая будет определять, является число четным или нечетным, потому что сами мы постоянно путаемся…\nВот она:\n\nodd_even &lt;- function(x) { # функция принимает на вход число\n  \n  if (x %% 2 == 0) { # проверяет, равняется ли нулю остаток от деления числа на два\n    \n    return(\"even\") # возвращает \"even\", если равняется\n    \n  } else {\n    \n    return(\"odd\") # возвращает \"odd\", если нет\n    \n  }\n  \n}\n\n\nodd_even(2)\n\n[1] \"even\"\n\nodd_even(34)\n\n[1] \"even\"\n\nodd_even(11)\n\n[1] \"odd\"\n\nodd_even(135)\n\n[1] \"odd\"\n\n\nРаботает!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#пример-функции-из-реального-проекта-с-условным-оператором",
    "href": "l1.html#пример-функции-из-реального-проекта-с-условным-оператором",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.11 Пример функции из реального проекта с условным оператором",
    "text": "1.11 Пример функции из реального проекта с условным оператором\n\n\n\n\n\n\nВажно!\n\n\n\nВам не нужно сейчас подробно понимать, что написано ниже — мы все разберем по ходу курса и научимся писать такое же! Сейчас главное ухватить структуру условного оператора — где условие, что выполняется, если условие верно, что выполняется, если условие ложно. Всё! Остальное освоим по ходу дела.\n\n\n\nms_preproc &lt;- function(d) {\n  \n  require(tidyverse)\n  \n  # Since we our participants could fill the fields in any order, \n  # here is a function which allows us to count correct inputs \n  # our subjects made.\n  \n  if (\"mouse_MSe.time\" %in% colnames(d)) { \n    ### здесь начинается условный оператор, который проверяет, есть ли такая колонка\n    ### если колонка есть, то запускается код ниже\n    \n    d |&gt; select(\n      \"Индивидуальный_код\",\n      matches(\"^noun\"),\n      matches(\"resp\\\\d\\\\.text$\"),\n      \"mouse_MSe.time\"\n    ) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:3)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"easy\") |&gt;\n      rename(\n        \"resp1\" = resp1.text,\n        \"resp2\" = resp2.text,\n        \"resp3\" = resp3.text,\n        \"id\" = \"Индивидуальный_код\",\n        \"rt\" = \"mouse_MSe.time\"\n      ) |&gt;\n      select(-c(paste0(\"noun\", 4:7))) -&gt; MS\n    \n  } else {\n    ### а если колонки нет, то запускается этот код\n    \n    d |&gt; select(\"Индивидуальный_код\",\n                matches(\"^noun\"),\n                matches(\"resp\\\\d\\\\.text$\")) |&gt;\n      filter_at(vars(paste0(\"noun\", 1:3)), all_vars(!is.na(.))) |&gt;\n      filter_at(vars(paste0(\"noun\", 4:7)), all_vars(is.na(.))) |&gt;\n      mutate(task = \"MS\",\n             level = \"easy\",\n             rt = NA) |&gt;\n      rename(\n        \"resp1\" = resp1.text,\n        \"resp2\" = resp2.text,\n        \"resp3\" = resp3.text,\n        \"id\" = \"Индивидуальный_код\"\n      ) |&gt;\n      select(-c(paste0(\"noun\", 4:7))) -&gt; MS\n\n  }\n  \n  return(MS)\n  \n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#вне-функций",
    "href": "l1.html#вне-функций",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.12 Вне функций",
    "text": "1.12 Вне функций\nВне функций условный оператор практически не используется, потому что для предобработки данных есть удобная функция ifelse().",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#циклы",
    "href": "l1.html#циклы",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.13 Циклы",
    "text": "1.13 Циклы\nТо, что мы написали функция, чтобы не дублировать код — это хорошо, однако эту функцию нам все равно придется запускать много раз, если нам надо этот кусок кода повторить.\nПоэтому используем цикл:\n\nfor (i in a:b) {\n  ...\n  body\n  ...\n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#пример-простеньких-циклов",
    "href": "l1.html#пример-простеньких-циклов",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.14 Пример простеньких циклов",
    "text": "1.14 Пример простеньких циклов\nПросто печатаем числа от 1 до 10:\n\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nНу, или более сложные выражения:\n\nfor (j in 1:10) {\n  print(sqrt(j) + j^2)\n}\n\n[1] 2\n[1] 5.414214\n[1] 10.73205\n[1] 18\n[1] 27.23607\n[1] 38.44949\n[1] 51.64575\n[1] 66.82843\n[1] 84\n[1] 103.1623",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#пример-цикла-для-чтения-и-предоработки-данных",
    "href": "l1.html#пример-цикла-для-чтения-и-предоработки-данных",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.15 Пример цикла для чтения и предоработки данных",
    "text": "1.15 Пример цикла для чтения и предоработки данных\n\n\n\n\n\n\nВажно!\n\n\n\nВам не нужно сейчас подробно понимать, что написано ниже — мы все разберем по ходу курса и научимся писать такое же! Сейчас главное ухватить структуру цикла — где итератор и где тело, которое будет выполняться несколько раз. Всё! Остальное освоим по ходу дела.\n\n\n\nfor (i in 1:length(files)) { ## будем двигаться от 1 до количества файлов в папке с данными\n  \n  print(files[i]) ## печатает имя файла, чтобы видеть на каком файле сломалось, если сломается\n  \n  d &lt;- read_csv(files[i], show_col_types = FALSE) ## считывает один файл из папки\n  \n  ## запускаем функции предобработки\n  MR_data |&gt; bind_rows(mr_preproc(d) |&gt; mutate(file = files[i])) -&gt; MR_data\n  ST_data |&gt; bind_rows(st_preproc(d) |&gt; mutate(file = files[i])) -&gt; ST_data\n  MS_data |&gt; bind_rows(ms_preproc(d) |&gt; mutate(file = files[i])) -&gt; MS_data\n  NASATLX_data |&gt; bind_rows(nasatlx_preproc(d) |&gt; mutate(file = files[i])) -&gt; NASATLX_data\n  SEQUENCE_data |&gt; bind_rows(sequence_preproc(d) |&gt; mutate(file = files[i])) -&gt; SEQUENCE_data\n  \n  ## завершили цикл, идем на следующую итерацию\n\n}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l1.html#циклы-в-r-это-зло-они-долго-работают",
    "href": "l1.html#циклы-в-r-это-зло-они-долго-работают",
    "title": "1  L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции",
    "section": "1.16 Циклы в R — это зло! Они долго работают!",
    "text": "1.16 Циклы в R — это зло! Они долго работают!\n\nДа, циклы работают не быстро — это правда. Но, с другой стороны, мы и не терабайты данных анализируем.\n\nДопустим, у нас 50 респондентов. Цикл, подобный тому, что на предыдущем слайде, отбработает секунды за 3. Даже чай не успеете заварить.\nБезусловно, есть более изящные и быстрые инструменты, и с ними мы познакомимся на предобработке данных. Но в целом, можно и циклом обойтись.\nКонечно, если у вас огромные датасеты и вы работаете с Big Data, то прогон цикла может значительно затянуться — в этом случае разумно сразу использовать другие инструменты.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции</span>"
    ]
  },
  {
    "objectID": "l2.html#форматы-файлов-данных",
    "href": "l2.html#форматы-файлов-данных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.1 Форматы файлов данных",
    "text": "2.1 Форматы файлов данных\n\n2.1.1 CSV\n\nТекстовый формат\nЗначения разделены запятыми (Comma-Separated Values)\n\nНо это не точно\n\n\nПрочитать данные этого формата можно функцией\n\nread.csv()\n\n\n\n2.1.2 TSV\n\nТекстовый формат\nЗначения разделены знаком табуляции (\\t, Tab-Separated Values)\n\nПрочитать данные этого формата можно функцией\n\nread.table()\n\n\n\n2.1.3 TXT\n\nТекстовый формат\nРазделитель может быть любой\n\nПрочитать данные этого формата можно функцией\n\nread.table()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#табличные-форматы",
    "href": "l2.html#табличные-форматы",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.2 Табличные форматы",
    "text": "2.2 Табличные форматы\n\nФайлы Excel — .xls, .xlsx\n\nДля их чтения понадобится пакет readxl, в котором есть функции\n\nreadxl::read_xls()\nreadxl::read_xlsx()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#форматы-файлов-данных-c-особой-разметкой",
    "href": "l2.html#форматы-файлов-данных-c-особой-разметкой",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.3 Форматы файлов данных c особой разметкой",
    "text": "2.3 Форматы файлов данных c особой разметкой\nВстречаются редко и обычно связаны с данными, которые достаются из интернета (парсинг страниц или выгрзуки JavaScript).\n\n2.3.1 JSON\nВыглядят так:\n\n{\n  \"first_name\": \"John\",\n  \"last_name\": \"Smith\",\n  \"is_alive\": true,\n  \"age\": 27,\n  \"address\": {\n    \"street_address\": \"21 2nd Street\",\n    \"city\": \"New York\",\n    \"state\": \"NY\",\n    \"postal_code\": \"10021-3100\"\n  },\n  \"phone_numbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [\n    \"Catherine\",\n    \"Thomas\",\n    \"Trevor\"\n  ],\n  \"spouse\": null\n}\n\nДля работы с ними пригодится пакет jsonlite.\n\n\n2.3.2 XML\nВыглядят так:\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;catalog&gt;\n   &lt;book id=\"bk101\"&gt;\n      &lt;author&gt;Gambardella, Matthew&lt;/author&gt;\n      &lt;title&gt;XML Developer's Guide&lt;/title&gt;\n      &lt;genre&gt;Computer&lt;/genre&gt;\n      &lt;price&gt;44.95&lt;/price&gt;\n      &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;\n      &lt;description&gt;An in-depth look at creating applications \n      with XML.&lt;/description&gt;\n   &lt;/book&gt;\n   &lt;book id=\"bk102\"&gt;\n      &lt;author&gt;Ralls, Kim&lt;/author&gt;\n      &lt;title&gt;Midnight Rain&lt;/title&gt;\n      &lt;genre&gt;Fantasy&lt;/genre&gt;\n      &lt;price&gt;5.95&lt;/price&gt;\n      &lt;publish_date&gt;2000-12-16&lt;/publish_date&gt;\n      &lt;description&gt;A former architect battles corporate zombies, \n      an evil sorceress, and her own childhood to become queen \n      of the world.&lt;/description&gt;\n   &lt;/book&gt;\n   &lt;book id=\"bk103\"&gt;\n      &lt;author&gt;Corets, Eva&lt;/author&gt;\n      &lt;title&gt;Maeve Ascendant&lt;/title&gt;\n      &lt;genre&gt;Fantasy&lt;/genre&gt;\n      &lt;price&gt;5.95&lt;/price&gt;\n      &lt;publish_date&gt;2000-11-17&lt;/publish_date&gt;\n      &lt;description&gt;After the collapse of a nanotechnology \n      society in England, the young survivors lay the \n      foundation for a new society.&lt;/description&gt;\n   &lt;/book&gt;\n&lt;/catalog&gt;\n\nДля работы с ними пригодится пакет XML.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#организация-рабочего-пространства",
    "href": "l2.html#организация-рабочего-пространства",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.4 Организация рабочего пространства",
    "text": "2.4 Организация рабочего пространства\nРабочая директория — папка, в которую по умолчанию смотрит R, когда начинает искать файлы.\nЧтобы узнать рабочую директорию, воспользуйтесь функцией\n\ngetwd()\n\nЧтобы установить какую-либо папку в каечстве рабочей директории, используйте\n\nsetwd(\"/home/nglgrdt/R\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#путь-к-файлу",
    "href": "l2.html#путь-к-файлу",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.5 Путь к файлу",
    "text": "2.5 Путь к файлу\nБывает двух видов:\n\nабсолютный — /home/nglgrdt/R/wlm2023/pr1-course.R\nотносительный — wlm2023/pr1-course.R\n\nОтносительный путь вычисляется относительно текущей рабочей директории.\nПолезная вещь: .. — подняться на один уровень в иерархии папок.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#projects",
    "href": "l2.html#projects",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.6 Projects",
    "text": "2.6 Projects\n\nRStudio предоставляет возможность работать в проектах\nЭто существено упрощает организацию файлов, относящихся к одному исследованию\nВнутри проекта можно создавать необходимые папки (для данных, скриптов, результатов анализа, визуализаций и др.)\nПри запуске проекта автоматически устанавливается рабочая директория\nУдобно использовать относительные пути к файлам\nЧтобы код воспроизводился на другом коспьютере, достаточно заархивировать весь проект и отправить коллеге\n\n\n2.6.1 Как создать проект?\n\nВ правом верхнем углу нажмите на Project: (None) и выберите New Project....\n\n\n\n\n\nСоздание проекта. Шаг 1\n\n\n\n\nВ открывшемся окне выберите New Directory. Это опция создаст новую папку для проекта.\n\n\n\n\n\nСоздание проекта. Шаг 2\n\n\n\n\nДалее выберите New Project.\n\n\n\n\n\nСоздание проекта. Шаг 3\n\n\n\n\nВ поле Directory name укажите, как будет называться папка проекта. В поле Create project as subdirectory of: можно выбрать, внутри какой папки создастся папка проекта. Нажмите Create Project.\n\n\n\n\n\nСоздание проекта. Шаг 4\n\n\n\n\nПроект создан и открыт. Теперь в нем можно работать. Чтобы узнать, в каком проекте вы сейчас находитесь, посмотрите в правый верхний угол.\n\n\n\n\n\nСоздание проекта. Шаг 5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#кодировка",
    "href": "l2.html#кодировка",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.7 Кодировка",
    "text": "2.7 Кодировка\n\nКомпьютер умеет хранить только числа, а скрипт — это текст\nДанные также часто содержат текст\nДоговорились, что буквеные символы будут храниться на железе компьютера в виде чисел и составили таблицы соответствий между числами и буквами\nТакие таблицы были названы кодировками\nКодировок много, так как они создавались для разных алфавитов и задач\nСтандартной считается UTF-8\nПри работе с нестандартными символами (например, диакритические знаки или фонетические символы) пригодится UTF-16",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#первичное-исследование-данных",
    "href": "l2.html#первичное-исследование-данных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.8 Первичное исследование данных",
    "text": "2.8 Первичное исследование данных\nПрочитаем данные. В данном случае использован относительный путь.\n\nlec2 &lt;- read.csv(\"data/lecture2.csv\", encoding = \"UTF-8\")\n\nВыведем первый 6 строк датасета:\n\nhead(lec2)\n\n  id var1 var2  var3  var4 var5\n1  1  Abc    5  TRUE cond1 12.8\n2  2  Def   16 FALSE cond1 14.2\n3  3  Ghi   94 FALSE cond2 32.5\n4  4  Jkl   28 FALSE cond2  9.4\n5  5  Mno   11  TRUE cond3  6.3\n6  6  Pqr  100  TRUE cond3 11.7\n\n\nВыведем последние 3 строки датасета:\n\ntail(lec2, n = 3)\n\n  id var1 var2  var3  var4 var5\n5  5  Mno   11  TRUE cond3  6.3\n6  6  Pqr  100  TRUE cond3 11.7\n7  7  Stu   96 FALSE cond1 95.5\n\n\nПосмотрим на структуру датасета:\n\nstr(lec2)\n\n'data.frame':   7 obs. of  6 variables:\n $ id  : int  1 2 3 4 5 6 7\n $ var1: chr  \"Abc\" \"Def\" \"Ghi\" \"Jkl\" ...\n $ var2: int  5 16 94 28 11 100 96\n $ var3: logi  TRUE FALSE FALSE FALSE TRUE TRUE ...\n $ var4: chr  \"cond1\" \"cond1\" \"cond2\" \"cond2\" ...\n $ var5: num  12.8 14.2 32.5 9.4 6.3 11.7 95.5\n\n\nПосмотрим описательные статистики по переменным:\n\nsummary(lec2)\n\n       id          var1                var2          var3        \n Min.   :1.0   Length:7           Min.   :  5.0   Mode :logical  \n 1st Qu.:2.5   Class :character   1st Qu.: 13.5   FALSE:4        \n Median :4.0   Mode  :character   Median : 28.0   TRUE :3        \n Mean   :4.0                      Mean   : 50.0                  \n 3rd Qu.:5.5                      3rd Qu.: 95.0                  \n Max.   :7.0                      Max.   :100.0                  \n     var4                var5      \n Length:7           Min.   : 6.30  \n Class :character   1st Qu.:10.55  \n Mode  :character   Median :12.80  \n                    Mean   :26.06  \n                    3rd Qu.:23.35  \n                    Max.   :95.50  \n\n\nСделаем частотную таблицу по категориальной переменной:\n\ntable(lec2$var4)\n\n\ncond1 cond2 cond3 \n    3     2     2 \n\n\nПосмотрим уникальные значений по переменной-индетификатору:\n\nunique(lec2$id)\n\n[1] 1 2 3 4 5 6 7\n\n\nОтсортируем количественную переменную по возрастанию:\n\nsort(lec2$var5)\n\n[1]  6.3  9.4 11.7 12.8 14.2 32.5 95.5\n\n\nПроверим, есть ли пропущенные значения — выполним функцию is.na() на каждом столце датасета:\n\napply(lec2, 2, is.na)\n\n        id  var1  var2  var3  var4  var5\n[1,] FALSE FALSE FALSE FALSE FALSE FALSE\n[2,] FALSE FALSE FALSE FALSE FALSE FALSE\n[3,] FALSE FALSE FALSE FALSE FALSE FALSE\n[4,] FALSE FALSE FALSE FALSE FALSE FALSE\n[5,] FALSE FALSE FALSE FALSE FALSE FALSE\n[6,] FALSE FALSE FALSE FALSE FALSE FALSE\n[7,] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nУпрощенным вариантом функции apply() является sapply() — она сразу запускает какую-либо функцию по столбцам датасета. В данному случае использована анонимная функция, которая посчитает количество пропущенных значений в каждом столбце.\n\nsapply(lec2, function(x) sum(is.na(x)))\n\n  id var1 var2 var3 var4 var5 \n   0    0    0    0    0    0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#зачем-нам-предобрабатывать-данные",
    "href": "l2.html#зачем-нам-предобрабатывать-данные",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.9 Зачем нам предобрабатывать данные?",
    "text": "2.9 Зачем нам предобрабатывать данные?\n\nДанные разнообразны в зависимости от того\n\nкакая у нас исследовательская область\nкакая у нас исследуемый феномен\nс каким оборудованием мы работаем\n…\n\nДля того, чтобы мы могли работать с данными независимо от того, откуда они к нам пришли, нам нужно привести их к некому стандартному виду",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#концепция-tidy-data",
    "href": "l2.html#концепция-tidy-data",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.10 Концепция Tidy Data",
    "text": "2.10 Концепция Tidy Data\n\nВ каждом столбце содержится одна переменная\nВ каждой строке содержится одно наблюдение\nВ каждой ячейке содержится одно значение\n\n\n\n\n\nПринципы концепции Tidy Data",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#семейство-пакетов-tidyverse",
    "href": "l2.html#семейство-пакетов-tidyverse",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.11 Семейство пакетов tidyverse",
    "text": "2.11 Семейство пакетов tidyverse\nУстановить пакет:\n\ninstall.packages(\"tidyverse\")\n\nПодключить пакет к текущей сессии R:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#импорт-данных.-tibble",
    "href": "l2.html#импорт-данных.-tibble",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.12 Импорт данных. tibble",
    "text": "2.12 Импорт данных. tibble\nФункции импорта данных из tidyverse атоматически читают данные в tibble. С точки зрения пользователя tibble — это тот же самый датафрейм. Есть некоторые отличия в выводе в консоль, с которыми мы ближе познакомимся на практике.\nДля чтения CSV-файлов есть следующие функции:\n\nread_csv()\nread_csv2()\n\nДля чтения данных с другими разделителями есть функция\n\nread_delim()\n\nЗагрузим данные:\n\nds &lt;- read_csv(\"data/lecture2.csv\")\n\nRows: 7 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): var1, var4\ndbl (3): id, var2, var5\nlgl (1): var3\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#pipe",
    "href": "l2.html#pipe",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.13 Pipe",
    "text": "2.13 Pipe\nПрежде чем начать разговор о предобработке, познакомимся с одним очень порезным оператором из tidyverse — это пайп.\nСуществует два вида пайпа:\n\nмаггритеровский %&gt;%\n\nтребуется подключение пакета tidyverse\n\nнативный |&gt;\n\nнаходится в базовом R, включается через настройки\n\nTools &gt; Global Options &gt; Code &gt; Use native pipe operator\n\n\n\nС точки зрения пользователя практически не отличаются друг от друга. И тот, и другой вводится комбинацией Ctrl + Shift + M. Выбрать, какой именно будет использоваться, можно в настройках (Tools &gt; Global Options &gt; Code &gt; Use native pipe operator.)\n\n\n\n\nВыбор используемого пайпа в настройках\n\n\n\nПайп передает то, что слева от него, в функцию, которая справа от него, в качестве первого аргумента.\n\nsum(1:3)\n\n[1] 6\n\n1:3 %&gt;% sum()\n\n[1] 6\n\n\n\nround(pi, 2)\n\n[1] 3.14\n\npi %&gt;% round(2)\n\n[1] 3.14\n\n\nПозволяет выстраивать цепочки последовательных преобразований:\n\nsqrt(abs(log(abs(round(sin(1 / cos(3)), 2)), 3)))\n\n[1] 0.3846181\n\n3 %&gt;% cos() %&gt;% \n  `/`(1, .) %&gt;% \n  sin() %&gt;% \n  round(2) %&gt;% \n  abs() %&gt;% \n  log(3) %&gt;% \n  abs() %&gt;% \n  sqrt()\n\n[1] 0.3846181",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#переименование-переменных",
    "href": "l2.html#переименование-переменных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.14 Переименование переменных",
    "text": "2.14 Переименование переменных\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\n\n\nds %&gt;% \n  rename(city = var1,\n         age = var2)\n\n# A tibble: 7 × 6\n     id city    age var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\n\n\nds %&gt;% \n  set_names(vars(id, city, age, student, condition, score))\n\n# A tibble: 7 × 6\n  `~id` `~city` `~age` `~student` `~condition` `~score`\n  &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;lgl&gt;      &lt;chr&gt;           &lt;dbl&gt;\n1     1 Abc          5 TRUE       cond1            12.8\n2     2 Def         16 FALSE      cond1            14.2\n3     3 Ghi         94 FALSE      cond2            32.5\n4     4 Jkl         28 FALSE      cond2             9.4\n5     5 Mno         11 TRUE       cond3             6.3\n6     6 Pqr        100 TRUE       cond3            11.7\n7     7 Stu         96 FALSE      cond1            95.5\n\n\n\nds %&gt;% \n  set_names(vars(id, city, age, student, condition, score)) %&gt;% \n  rename_all(str_remove, \"~\")\n\n# A tibble: 7 × 6\n     id city    age student condition score\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;   &lt;chr&gt;     &lt;dbl&gt;\n1     1 Abc       5 TRUE    cond1      12.8\n2     2 Def      16 FALSE   cond1      14.2\n3     3 Ghi      94 FALSE   cond2      32.5\n4     4 Jkl      28 FALSE   cond2       9.4\n5     5 Mno      11 TRUE    cond3       6.3\n6     6 Pqr     100 TRUE    cond3      11.7\n7     7 Stu      96 FALSE   cond1      95.5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#фильтрация-данных.-строки",
    "href": "l2.html#фильтрация-данных.-строки",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.15 Фильтрация данных. Строки",
    "text": "2.15 Фильтрация данных. Строки\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  filter(var5 &gt; 10)\n\n# A tibble: 5 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     6 Pqr     100 TRUE  cond3  11.7\n5     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  filter(var3)\n\n# A tibble: 3 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     5 Mno      11 TRUE  cond3   6.3\n3     6 Pqr     100 TRUE  cond3  11.7\n\nds %&gt;% slice(3:5)\n\n# A tibble: 3 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     3 Ghi      94 FALSE cond2  32.5\n2     4 Jkl      28 FALSE cond2   9.4\n3     5 Mno      11 TRUE  cond3   6.3",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#фильтрация-данных.-столбцы",
    "href": "l2.html#фильтрация-данных.-столбцы",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.16 Фильтрация данных. Столбцы",
    "text": "2.16 Фильтрация данных. Столбцы\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  select(id, var1, var3, var4)\n\n# A tibble: 7 × 4\n     id var1  var3  var4 \n  &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt;\n1     1 Abc   TRUE  cond1\n2     2 Def   FALSE cond1\n3     3 Ghi   FALSE cond2\n4     4 Jkl   FALSE cond2\n5     5 Mno   TRUE  cond3\n6     6 Pqr   TRUE  cond3\n7     7 Stu   FALSE cond1\n\nds %&gt;% \n  select(starts_with(\"var\"))\n\n# A tibble: 7 × 5\n  var1   var2 var3  var4   var5\n  &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1 Abc       5 TRUE  cond1  12.8\n2 Def      16 FALSE cond1  14.2\n3 Ghi      94 FALSE cond2  32.5\n4 Jkl      28 FALSE cond2   9.4\n5 Mno      11 TRUE  cond3   6.3\n6 Pqr     100 TRUE  cond3  11.7\n7 Stu      96 FALSE cond1  95.5",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#сортировка-данных",
    "href": "l2.html#сортировка-данных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.17 Сортировка данных",
    "text": "2.17 Сортировка данных\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  arrange(var5)\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     5 Mno      11 TRUE  cond3   6.3\n2     4 Jkl      28 FALSE cond2   9.4\n3     6 Pqr     100 TRUE  cond3  11.7\n4     1 Abc       5 TRUE  cond1  12.8\n5     2 Def      16 FALSE cond1  14.2\n6     3 Ghi      94 FALSE cond2  32.5\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  arrange(desc(var5))\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     7 Stu      96 FALSE cond1  95.5\n2     3 Ghi      94 FALSE cond2  32.5\n3     2 Def      16 FALSE cond1  14.2\n4     1 Abc       5 TRUE  cond1  12.8\n5     6 Pqr     100 TRUE  cond3  11.7\n6     4 Jkl      28 FALSE cond2   9.4\n7     5 Mno      11 TRUE  cond3   6.3\n\nds %&gt;% \n  distinct(var4, var3)\n\n# A tibble: 4 × 2\n  var4  var3 \n  &lt;chr&gt; &lt;lgl&gt;\n1 cond1 TRUE \n2 cond1 FALSE\n3 cond2 FALSE\n4 cond3 TRUE",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#создание-и-изменение-переменных",
    "href": "l2.html#создание-и-изменение-переменных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.18 Создание и изменение переменных",
    "text": "2.18 Создание и изменение переменных\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  mutate(banch = 1)\n\n# A tibble: 7 × 7\n     id var1   var2 var3  var4   var5 banch\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8     1\n2     2 Def      16 FALSE cond1  14.2     1\n3     3 Ghi      94 FALSE cond2  32.5     1\n4     4 Jkl      28 FALSE cond2   9.4     1\n5     5 Mno      11 TRUE  cond3   6.3     1\n6     6 Pqr     100 TRUE  cond3  11.7     1\n7     7 Stu      96 FALSE cond1  95.5     1\n\nds %&gt;% \n  mutate(banch = 1,\n         var5_cat = ifelse(var5 &gt; mean(var5), \"high\", \"low\"),\n         var4 = recode(var4,\n                       \"cond1\" = \"easy\",\n                       \"cond2\" = \"medium\",\n                       \"cond3\" = \"hard\"))\n\n# A tibble: 7 × 8\n     id var1   var2 var3  var4    var5 banch var5_cat\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   \n1     1 Abc       5 TRUE  easy    12.8     1 low     \n2     2 Def      16 FALSE easy    14.2     1 low     \n3     3 Ghi      94 FALSE medium  32.5     1 high    \n4     4 Jkl      28 FALSE medium   9.4     1 low     \n5     5 Mno      11 TRUE  hard     6.3     1 low     \n6     6 Pqr     100 TRUE  hard    11.7     1 low     \n7     7 Stu      96 FALSE easy    95.5     1 high",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#группировка-и-аггрегация-данных",
    "href": "l2.html#группировка-и-аггрегация-данных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.19 Группировка и аггрегация данных",
    "text": "2.19 Группировка и аггрегация данных\n\nds\n\n# A tibble: 7 × 6\n     id var1   var2 var3  var4   var5\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 TRUE  cond1  12.8\n2     2 Def      16 FALSE cond1  14.2\n3     3 Ghi      94 FALSE cond2  32.5\n4     4 Jkl      28 FALSE cond2   9.4\n5     5 Mno      11 TRUE  cond3   6.3\n6     6 Pqr     100 TRUE  cond3  11.7\n7     7 Stu      96 FALSE cond1  95.5\n\nds %&gt;% \n  summarise(v5_mean = mean(var5),\n            v2_median = median(var2))\n\n# A tibble: 1 × 2\n  v5_mean v2_median\n    &lt;dbl&gt;     &lt;dbl&gt;\n1    26.1        28\n\nds %&gt;% \n  group_by(var4) %&gt;% \n  summarise(n = n(),\n            v5_mean = mean(var5),\n            v2_median = median(var2))\n\n# A tibble: 3 × 4\n  var4      n v5_mean v2_median\n  &lt;chr&gt; &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n1 cond1     3    40.8      16  \n2 cond2     2    21.0      61  \n3 cond3     2     9        55.5\n\nds %&gt;% \n  summarise(n = n(),\n            v5_mean = mean(var5),\n            v2_median = median(var2),\n            .by = var4)\n\n# A tibble: 3 × 4\n  var4      n v5_mean v2_median\n  &lt;chr&gt; &lt;int&gt;   &lt;dbl&gt;     &lt;dbl&gt;\n1 cond1     3    40.8      16  \n2 cond2     2    21.0      61  \n3 cond3     2     9        55.5\n\n\n\nungroup()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#объединение-датасетов.-строки-и-столбцы",
    "href": "l2.html#объединение-датасетов.-строки-и-столбцы",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.20 Объединение датасетов. Строки и столбцы",
    "text": "2.20 Объединение датасетов. Строки и столбцы\n\na\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     3 Ghi      94\n4     4 Jkl      28\n\nb\n\n# A tibble: 4 × 3\n     id var3  var4 \n  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;\n1     1 TRUE  cond1\n2     2 FALSE cond1\n3     3 FALSE cond2\n4     4 FALSE cond2\n\nc\n\n# A tibble: 3 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     5 Mno      11\n2     6 Pqr     100\n3     7 Stu      96\n\na %&gt;% \n  bind_cols(b)\n\nNew names:\n• `id` -&gt; `id...1`\n• `id` -&gt; `id...4`\n\n\n# A tibble: 4 × 6\n  id...1 var1   var2 id...4 var3  var4 \n   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;\n1      1 Abc       5      1 TRUE  cond1\n2      2 Def      16      2 FALSE cond1\n3      3 Ghi      94      3 FALSE cond2\n4      4 Jkl      28      4 FALSE cond2\n\na %&gt;% \n  bind_rows(c)\n\n# A tibble: 7 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     3 Ghi      94\n4     4 Jkl      28\n5     5 Mno      11\n6     6 Pqr     100\n7     7 Stu      96",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#объединение-датасетов.-ключ",
    "href": "l2.html#объединение-датасетов.-ключ",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.21 Объединение датасетов. Ключ",
    "text": "2.21 Объединение датасетов. Ключ\n\n\n\n\nСхема датасетов\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#inner_join",
    "href": "l2.html#inner_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.22 inner_join()",
    "text": "2.22 inner_join()\n\n\n\n\nСхема inner_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% inner_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 2 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     2 Def      16 cond1  14.2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#left_join",
    "href": "l2.html#left_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.23 left_join()",
    "text": "2.23 left_join()\n\n\n\n\nСхема left_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% left_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 4 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     2 Def      16 cond1  14.2\n3     5 Mno      11 &lt;NA&gt;   NA  \n4     7 Stu      96 &lt;NA&gt;   NA",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#right_join",
    "href": "l2.html#right_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.24 right_join()",
    "text": "2.24 right_join()\n\n\n\n\nСхема right_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% right_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 4 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     2 Def      16 cond1  14.2\n3     3 &lt;NA&gt;     NA cond2  32.5\n4     4 &lt;NA&gt;     NA cond2   9.4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#full_join",
    "href": "l2.html#full_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.25 full_join()",
    "text": "2.25 full_join()\n\n\n\n\nСхема full_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% full_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 6 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     2 Def      16 cond1  14.2\n3     5 Mno      11 &lt;NA&gt;   NA  \n4     7 Stu      96 &lt;NA&gt;   NA  \n5     3 &lt;NA&gt;     NA cond2  32.5\n6     4 &lt;NA&gt;     NA cond2   9.4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#semi_join",
    "href": "l2.html#semi_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.26 semi_join()",
    "text": "2.26 semi_join()\n\n\n\n\nСхема semi_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% semi_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 2 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n\ny %&gt;% semi_join(x)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 2 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#anti_join",
    "href": "l2.html#anti_join",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.27 anti_join()",
    "text": "2.27 anti_join()\n\n\n\n\nСхема anti_join()\n\n\n\n\n\nx\n\n# A tibble: 4 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     2 Def      16\n3     5 Mno      11\n4     7 Stu      96\n\ny\n\n# A tibble: 4 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     3 cond2  32.5\n4     4 cond2   9.4\n\nx %&gt;% anti_join(y)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 2 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     5 Mno      11\n2     7 Stu      96\n\ny %&gt;% anti_join(x)\n\nJoining with `by = join_by(id)`\n\n\n# A tibble: 2 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     3 cond2  32.5\n2     4 cond2   9.4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#дублирование-ключа",
    "href": "l2.html#дублирование-ключа",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.28 Дублирование ключа",
    "text": "2.28 Дублирование ключа\n\n\n\n\nСхема работы .._join() при наличии дублей в колонке ключа\n\n\n\n\n\nx\n\n# A tibble: 5 × 3\n     id var1   var2\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5\n2     1 Abc       7\n3     2 Def      16\n4     5 Mno      11\n5     7 Stu      96\n\ny\n\n# A tibble: 5 × 3\n     id var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     2 cond2   2  \n4     3 cond2  32.5\n5     4 cond2   9.4\n\nx %&gt;% inner_join(y)\n\nJoining with `by = join_by(id)`\n\n\nWarning in inner_join(., y): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 3 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n# A tibble: 4 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     1 Abc       7 cond1  12.8\n3     2 Def      16 cond1  14.2\n4     2 Def      16 cond2   2  \n\nx %&gt;% left_join(y)\n\nJoining with `by = join_by(id)`\n\n\nWarning in left_join(., y): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 3 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n# A tibble: 6 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     1 Abc       7 cond1  12.8\n3     2 Def      16 cond1  14.2\n4     2 Def      16 cond2   2  \n5     5 Mno      11 &lt;NA&gt;   NA  \n6     7 Stu      96 &lt;NA&gt;   NA  \n\nx %&gt;% right_join(y)\n\nJoining with `by = join_by(id)`\n\n\nWarning in right_join(., y): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 3 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n# A tibble: 6 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     1 Abc       7 cond1  12.8\n3     2 Def      16 cond1  14.2\n4     2 Def      16 cond2   2  \n5     3 &lt;NA&gt;     NA cond2  32.5\n6     4 &lt;NA&gt;     NA cond2   9.4\n\nx %&gt;% full_join(y)\n\nJoining with `by = join_by(id)`\n\n\nWarning in full_join(., y): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 3 of `x` matches multiple rows in `y`.\nℹ Row 1 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n# A tibble: 8 × 5\n     id var1   var2 var3   var4\n  &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 Abc       5 cond1  12.8\n2     1 Abc       7 cond1  12.8\n3     2 Def      16 cond1  14.2\n4     2 Def      16 cond2   2  \n5     5 Mno      11 &lt;NA&gt;   NA  \n6     7 Stu      96 &lt;NA&gt;   NA  \n7     3 &lt;NA&gt;     NA cond2  32.5\n8     4 &lt;NA&gt;     NA cond2   9.4",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#способы-объединения-по-ключу-на-диаграммах-венна",
    "href": "l2.html#способы-объединения-по-ключу-на-диаграммах-венна",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.29 Способы объединения по ключу на диаграммах Венна",
    "text": "2.29 Способы объединения по ключу на диаграммах Венна\n\n\n\n\nСхема работы .._join() на диаграммах Венна",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#широкий-и-длинный-форматы-данных",
    "href": "l2.html#широкий-и-длинный-форматы-данных",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.30 Широкий и длинный форматы данных",
    "text": "2.30 Широкий и длинный форматы данных\n\n\n\n\nПредставление одних и тех же данных в длинном и широком форматах\n\n\n\n\nlong\n\n# A tibble: 6 × 3\n     id var1   var2\n  &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     2 cond1  14.2\n3     1 cond2  32.5\n4     2 cond2   9.4\n5     1 cond3   6.3\n6     2 cond3  11.7\n\nlong %&gt;% \n  pivot_wider(names_from = var1,\n              values_from = var2) -&gt; wide\nwide\n\n# A tibble: 2 × 4\n     id cond1 cond2 cond3\n  &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1     1  12.8  32.5   6.3\n2     2  14.2   9.4  11.7\n\nwide %&gt;% \n  pivot_longer(cols = -id) # names_to, values_to\n\n# A tibble: 6 × 3\n     id name  value\n  &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;\n1     1 cond1  12.8\n2     1 cond2  32.5\n3     1 cond3   6.3\n4     2 cond1  14.2\n5     2 cond2   9.4\n6     2 cond3  11.7",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#строки",
    "href": "l2.html#строки",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.31 Строки",
    "text": "2.31 Строки\nДва специализированных пакета:\n\nstringr (является частью tidyverse)\nstringi (устанавливается отдельно)\n\n\n# install.packages(\"stringi\")\nlibrary(stringi)\n\n\n2.31.1 Как создать строку?\n\ns1 &lt;- \"сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений\"\ns1\n\n[1] \"сложившаяся структура организации влечет за собой процесс внедрения и модернизации новых предложений\"\n\n\n\ns2 &lt;- 'С другой стороны постоянный количественный \"рост\" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации'\ns2\n\n[1] \"С другой стороны постоянный количественный \\\"рост\\\" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"\n\n\n\ns3 &lt;- \"С другой стороны постоянный количественный \"рост\" и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"\ns3\n\nError: &lt;text&gt;:1:52: unexpected symbol\n1: s3 &lt;- \"С другой стороны постоянный количественный \"рост\n                                                       ^\n\n\n\ns4 &lt;- \"С другой стороны постоянный количественный 'рост' и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"\ns4\n\n[1] \"С другой стороны постоянный количественный 'рост' и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"\n\n\n\ns5 &lt;- \"С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"\ns5\n\n[1] \"С другой стороны постоянный количественный «рост» и сфера нашей активности позволяет выполнять важные задания по разработке соответствующий условий активизации\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#генерация-случайных-строк",
    "href": "l2.html#генерация-случайных-строк",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.32 Генерация случайных строк",
    "text": "2.32 Генерация случайных строк\n\nstri_rand_strings(n = 10, length = 5)\n\n [1] \"mJuOz\" \"zKeS8\" \"e3ITF\" \"gSNpV\" \"n9cpe\" \"mJae6\" \"qLZ3B\" \"wTBUV\" \"pQtPm\"\n[10] \"5xKeV\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#операции-над-строками",
    "href": "l2.html#операции-над-строками",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.33 Операции над строками",
    "text": "2.33 Операции над строками\n\n2.33.1 Конкатенация строк\n\npaste('first', 'second', 'third')\n\n[1] \"first second third\"\n\n\n\npaste('first', 'second', 'third', sep = \"_\")\n\n[1] \"first_second_third\"\n\n\n\npaste0('first', 'second', 'third')\n\n[1] \"firstsecondthird\"\n\n\n\nstr_c('first', 'second', 'third')\n\n[1] \"firstsecondthird\"\n\n\n\nstr_c('first', 'second', 'third', sep = \"|\")\n\n[1] \"first|second|third\"\n\n\n\nstri_c('first', 'second', 'third')\n\n[1] \"firstsecondthird\"\n\n\n\nstri_c('first', 'second', 'third', sep = \" & \")\n\n[1] \"first & second & third\"\n\n\n\nds_1\n\n# A tibble: 150 × 4\n      id scale  item score\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt;\n 1     1 A         1     3\n 2     1 A         2     2\n 3     1 A         3     2\n 4     1 A         4     5\n 5     1 A         5     3\n 6     1 B         1     3\n 7     1 B         2     4\n 8     1 B         3     3\n 9     1 B         4     1\n10     1 B         5     4\n# ℹ 140 more rows\n\nds_1 %&gt;% \n  unite(scale_item, scale, item, sep = \"_\") -&gt; ds_2\nds_2\n\n# A tibble: 150 × 3\n      id scale_item score\n   &lt;int&gt; &lt;chr&gt;      &lt;int&gt;\n 1     1 A_1            3\n 2     1 A_2            2\n 3     1 A_3            2\n 4     1 A_4            5\n 5     1 A_5            3\n 6     1 B_1            3\n 7     1 B_2            4\n 8     1 B_3            3\n 9     1 B_4            1\n10     1 B_5            4\n# ℹ 140 more rows",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#операции-над-строками-1",
    "href": "l2.html#операции-над-строками-1",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.34 Операции над строками",
    "text": "2.34 Операции над строками\n\n2.34.1 Разделение строк\n\nstr_split(\"first second third\", pattern = \" \")\n\n[[1]]\n[1] \"first\"  \"second\" \"third\" \n\n\n\nds_2 %&gt;% \n  separate(scale_item, into = c(\"scale\", \"item\"))\n\n# A tibble: 150 × 4\n      id scale item  score\n   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 A     1         3\n 2     1 A     2         2\n 3     1 A     3         2\n 4     1 A     4         5\n 5     1 A     5         3\n 6     1 B     1         3\n 7     1 B     2         4\n 8     1 B     3         3\n 9     1 B     4         1\n10     1 B     5         4\n# ℹ 140 more rows",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#сортировка-строк",
    "href": "l2.html#сортировка-строк",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.35 Сортировка строк",
    "text": "2.35 Сортировка строк\n\nunsorted_s\n\n [1] \"Odl\" \"Snm\" \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"Swx\" \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"Szq\"\n\n\n\nsort(unsorted_s)\n\n [1] \"Ccw\" \"Cka\" \"Ejt\" \"Eph\" \"Gbz\" \"Hfj\" \"Ixs\" \"Iyc\" \"Jgf\" \"Jhe\" \"Koi\" \"Nqr\"\n[13] \"Nvd\" \"Odl\" \"Ruu\" \"Snm\" \"Swx\" \"Szq\" \"Tmp\" \"Vin\" \"Vlo\" \"Yey\" \"Ysv\" \"Ytg\"\n[25] \"Zab\" \"Zrk\"\n\n\n\nstr_sort(unsorted_s)\n\n [1] \"Ccw\" \"Cka\" \"Ejt\" \"Eph\" \"Gbz\" \"Hfj\" \"Ixs\" \"Iyc\" \"Jgf\" \"Jhe\" \"Koi\" \"Nqr\"\n[13] \"Nvd\" \"Odl\" \"Ruu\" \"Snm\" \"Swx\" \"Szq\" \"Tmp\" \"Vin\" \"Vlo\" \"Yey\" \"Ysv\" \"Ytg\"\n[25] \"Zab\" \"Zrk\"\n\n\n\n# по умолчанию\nstr_sort(c(\"э\", \"а\", \"у\", \"i\"), locale = 'en')\n\n[1] \"i\" \"а\" \"у\" \"э\"\n\n\n\n# для русского языка\nstr_sort(c(\"э\", \"а\", \"у\", \"i\"), locale = 'ru')\n\n[1] \"а\" \"у\" \"э\" \"i\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#изменение-строк",
    "href": "l2.html#изменение-строк",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.36 Изменение строк",
    "text": "2.36 Изменение строк\n\n2.36.1 Выделение подстроки\n\nunsorted_s\n\n [1] \"Odl\" \"Snm\" \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"Swx\" \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"Szq\"\n\nstr_sub(unsorted_s, start = 1, end = 2)\n\n [1] \"Od\" \"Sn\" \"Nq\" \"Ck\" \"Jg\" \"Ru\" \"Vl\" \"Ko\" \"Ej\" \"Tm\" \"Nv\" \"Vi\" \"Ys\" \"Zr\" \"Ep\"\n[16] \"Sw\" \"Ye\" \"Yt\" \"Ix\" \"Cc\" \"Hf\" \"Za\" \"Gb\" \"Jh\" \"Iy\" \"Sz\"\n\n\n\n\n2.36.2 Замена подстроки\n\nunsorted_s\n\n [1] \"Odl\" \"Snm\" \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"Swx\" \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"Szq\"\n\nstr_replace(unsorted_s, pattern = \"O\", replacement = \"Ь\")\n\n [1] \"Ьdl\" \"Snm\" \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"Swx\" \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"Szq\"\n\n\n\n\n2.36.3 Удаление подстроки\n\nunsorted_s\n\n [1] \"Odl\" \"Snm\" \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"Swx\" \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"Szq\"\n\nstr_remove(unsorted_s, \"S\")\n\n [1] \"Odl\" \"nm\"  \"Nqr\" \"Cka\" \"Jgf\" \"Ruu\" \"Vlo\" \"Koi\" \"Ejt\" \"Tmp\" \"Nvd\" \"Vin\"\n[13] \"Ysv\" \"Zrk\" \"Eph\" \"wx\"  \"Yey\" \"Ytg\" \"Ixs\" \"Ccw\" \"Hfj\" \"Zab\" \"Gbz\" \"Jhe\"\n[25] \"Iyc\" \"zq\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#регулярные-выражения",
    "href": "l2.html#регулярные-выражения",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.37 Регулярные выражения",
    "text": "2.37 Регулярные выражения\n\ndates &lt;- c('21.92.2001', '01.04.1994', '5-3-2011', '6/04/1999')\ndates\n\n[1] \"21.92.2001\" \"01.04.1994\" \"5-3-2011\"   \"6/04/1999\" \n\n\n\n2.37.1 Метасимволы\n\nstr_view_all(dates, pattern = \".\")\n\nWarning: `str_view()` was deprecated in stringr 1.5.0.\nℹ Please use `str_view_all()` instead.\n\n\n[1] │ &lt;2&gt;&lt;1&gt;&lt;.&gt;&lt;9&gt;&lt;2&gt;&lt;.&gt;&lt;2&gt;&lt;0&gt;&lt;0&gt;&lt;1&gt;\n[2] │ &lt;0&gt;&lt;1&gt;&lt;.&gt;&lt;0&gt;&lt;4&gt;&lt;.&gt;&lt;1&gt;&lt;9&gt;&lt;9&gt;&lt;4&gt;\n[3] │ &lt;5&gt;&lt;-&gt;&lt;3&gt;&lt;-&gt;&lt;2&gt;&lt;0&gt;&lt;1&gt;&lt;1&gt;\n[4] │ &lt;6&gt;&lt;/&gt;&lt;0&gt;&lt;4&gt;&lt;/&gt;&lt;1&gt;&lt;9&gt;&lt;9&gt;&lt;9&gt;\n\n\n\nstr_view_all(dates, pattern = \"\\\\.\") # экранирование метасимволов\n\n[1] │ 21&lt;.&gt;92&lt;.&gt;2001\n[2] │ 01&lt;.&gt;04&lt;.&gt;1994\n[3] │ 5-3-2011\n[4] │ 6/04/1999\n\n\n\nstr_view_all(dates, pattern = \"^0\")\n\n[1] │ 21.92.2001\n[2] │ &lt;0&gt;1.04.1994\n[3] │ 5-3-2011\n[4] │ 6/04/1999\n\n\n\nstr_view_all(dates, pattern = \"9$\")\n\n[1] │ 21.92.2001\n[2] │ 01.04.1994\n[3] │ 5-3-2011\n[4] │ 6/04/199&lt;9&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#регулярные-выражения-1",
    "href": "l2.html#регулярные-выражения-1",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.38 Регулярные выражения",
    "text": "2.38 Регулярные выражения\n\n2.38.1 Классы знаков\n\nstr_view_all(dates, pattern = '\\\\d') # ищем цифры\n\n[1] │ &lt;2&gt;&lt;1&gt;.&lt;9&gt;&lt;2&gt;.&lt;2&gt;&lt;0&gt;&lt;0&gt;&lt;1&gt;\n[2] │ &lt;0&gt;&lt;1&gt;.&lt;0&gt;&lt;4&gt;.&lt;1&gt;&lt;9&gt;&lt;9&gt;&lt;4&gt;\n[3] │ &lt;5&gt;-&lt;3&gt;-&lt;2&gt;&lt;0&gt;&lt;1&gt;&lt;1&gt;\n[4] │ &lt;6&gt;/&lt;0&gt;&lt;4&gt;/&lt;1&gt;&lt;9&gt;&lt;9&gt;&lt;9&gt;\n\n\n\nstr_view_all(dates, pattern = '\\\\D') # ищем не-цифры\n\n[1] │ 21&lt;.&gt;92&lt;.&gt;2001\n[2] │ 01&lt;.&gt;04&lt;.&gt;1994\n[3] │ 5&lt;-&gt;3&lt;-&gt;2011\n[4] │ 6&lt;/&gt;04&lt;/&gt;1999\n\n\n\nstr_view_all('успешный успех', '\\\\s') # пробелы\n\n[1] │ успешный&lt; &gt;успех\n\n\n\nstr_view_all('успешный успех', '\\\\S') # не-пробелы\n\n[1] │ &lt;у&gt;&lt;с&gt;&lt;п&gt;&lt;е&gt;&lt;ш&gt;&lt;н&gt;&lt;ы&gt;&lt;й&gt; &lt;у&gt;&lt;с&gt;&lt;п&gt;&lt;е&gt;&lt;х&gt;\n\n\n\nstr_view_all('верно ведь, что здесь что-то есть', '\\\\w') # не пробелы и не знаки препинания\n\n[1] │ &lt;в&gt;&lt;е&gt;&lt;р&gt;&lt;н&gt;&lt;о&gt; &lt;в&gt;&lt;е&gt;&lt;д&gt;&lt;ь&gt;, &lt;ч&gt;&lt;т&gt;&lt;о&gt; &lt;з&gt;&lt;д&gt;&lt;е&gt;&lt;с&gt;&lt;ь&gt; &lt;ч&gt;&lt;т&gt;&lt;о&gt;-&lt;т&gt;&lt;о&gt; &lt;е&gt;&lt;с&gt;&lt;т&gt;&lt;ь&gt;\n\n\n\nstr_view_all('верно ведь, что здесь что-то есть', '\\\\W') # пробелы и знаки препинания\n\n[1] │ верно&lt; &gt;ведь&lt;,&gt;&lt; &gt;что&lt; &gt;здесь&lt; &gt;что&lt;-&gt;то&lt; &gt;есть",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#регулярные-выражения-2",
    "href": "l2.html#регулярные-выражения-2",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.39 Регулярные выражения",
    "text": "2.39 Регулярные выражения\n\n2.39.1 Квантификация\n\n? — ноль или один раз\n* — ноль или более раз\n+ — один или более раз\n{n} — n раз\n\n\nstr_view_all(dates, '\\\\d{2}')\n\n[1] │ &lt;21&gt;.&lt;92&gt;.&lt;20&gt;&lt;01&gt;\n[2] │ &lt;01&gt;.&lt;04&gt;.&lt;19&gt;&lt;94&gt;\n[3] │ 5-3-&lt;20&gt;&lt;11&gt;\n[4] │ 6/&lt;04&gt;/&lt;19&gt;&lt;99&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#дата-и-время",
    "href": "l2.html#дата-и-время",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.40 Дата и время",
    "text": "2.40 Дата и время\n\n2.40.1 Почему это особый тип данных?\n\nГод ≠ 365 дней: високосные года\nСутки ≠ 24 часа: переход на зимнее и летнее время\nМинута ≠ 60 секунд: компенсация замедления вращения земли (30 июня 23:59:60 или 31 декабря 23:59:60)\n\nВсе это автоматически обрабатывает lubridate.\n\ntoday()\n\n[1] \"2023-12-29\"\n\n\n\nnow()\n\n[1] \"2023-12-29 20:20:31 MSK\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#форматы-даты-и-времени",
    "href": "l2.html#форматы-даты-и-времени",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.41 Форматы даты и времени",
    "text": "2.41 Форматы даты и времени\n\nyyyy-mm-dd — является международным стандартом\n\nв таком формате с датой можно работать как со строкой, что оказывается удобно для баз данных\n\ndd/mm/yy, dd/mm/yyyy, dd.mm.yyyy — используется в Европе\nmm/dd/yy, mm/dd/yyyy — используется в США\nUnix-timestamp (число) — количество секунд с 01.01.1970, используется в базах данных",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#операции-над-датами",
    "href": "l2.html#операции-над-датами",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.42 Операции над датами",
    "text": "2.42 Операции над датами\n\n## текущий timestamp\nas.numeric(now())\n\n[1] 1703870432\n\n\n\nyear(now())\n\n[1] 2023\n\nmonth(now())\n\n[1] 12\n\nday(now())\n\n[1] 29\n\nhour(now())\n\n[1] 20\n\nminute(now())\n\n[1] 20\n\nsecond(now())\n\n[1] 31.75173\n\ndifftime(ymd_hm(\"2023-01-21, 21:00\"), ymd_hm(\"2023-01-21, 18:10\"), units = \"mins\")\n\nTime difference of 170 mins",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#зачем-нужна-визуализация",
    "href": "l2.html#зачем-нужна-визуализация",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.43 Зачем нужна визуализация?",
    "text": "2.43 Зачем нужна визуализация?\n\n2.43.1 Квартет Анскомба\n\n\nRows: 44 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (4): id, dataset, x, y\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nspc_tbl_ [44 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ id     : num [1:44] 1 1 1 1 2 2 2 2 3 3 ...\n $ dataset: num [1:44] 1 2 3 4 1 2 3 4 1 2 ...\n $ x      : num [1:44] 10 10 10 8 8 8 8 8 13 13 ...\n $ y      : num [1:44] 8.04 9.14 7.46 6.58 6.95 8.14 6.77 5.76 7.58 8.74 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   id = col_double(),\n  ..   dataset = col_double(),\n  ..   x = col_double(),\n  ..   y = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\n\n\n# A tibble: 4 × 7\n  dataset     n mean_x mean_y  sd_x  sd_y   cor\n    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1       1    11      9    7.5  3.32  2.03  0.82\n2       2    11      9    7.5  3.32  2.03  0.82\n3       3    11      9    7.5  3.32  2.03  0.82\n4       4    11      9    7.5  3.32  2.03  0.82\n\n\nНо если это нарисовать, получим такое:\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n2.43.2 Datasaurus\n\n\nRows: 1846 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): dataset\ndbl (2): x, y\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nspc_tbl_ [1,846 × 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ dataset: chr [1:1846] \"dino\" \"dino\" \"dino\" \"dino\" ...\n $ x      : num [1:1846] 55.4 51.5 46.2 42.8 40.8 ...\n $ y      : num [1:1846] 97.2 96 94.5 91.4 88.3 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   dataset = col_character(),\n  ..   x = col_double(),\n  ..   y = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\n\n\n# A tibble: 13 × 7\n   dataset        n mean_x mean_y  sd_x  sd_y   cor\n   &lt;chr&gt;      &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 away         142   54.3   47.8  16.8  26.9  -0.1\n 2 bullseye     142   54.3   47.8  16.8  26.9  -0.1\n 3 circle       142   54.3   47.8  16.8  26.9  -0.1\n 4 dino         142   54.3   47.8  16.8  26.9  -0.1\n 5 dots         142   54.3   47.8  16.8  26.9  -0.1\n 6 h_lines      142   54.3   47.8  16.8  26.9  -0.1\n 7 high_lines   142   54.3   47.8  16.8  26.9  -0.1\n 8 slant_down   142   54.3   47.8  16.8  26.9  -0.1\n 9 slant_up     142   54.3   47.8  16.8  26.9  -0.1\n10 star         142   54.3   47.8  16.8  26.9  -0.1\n11 v_lines      142   54.3   47.8  16.8  26.9  -0.1\n12 wide_lines   142   54.3   47.8  16.8  26.9  -0.1\n13 x_shape      142   54.3   47.8  16.8  26.9  -0.1\n\n\nОднако если это визуализировать, то будет вот что:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#виды-графиков",
    "href": "l2.html#виды-графиков",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.44 Виды графиков",
    "text": "2.44 Виды графиков\n\n2.44.1 Столбчатая диаграмма (Bar plot, Bar graph)\n\n\n\n\n\n\n\n\n\n\n\n2.44.2 Лучевая диаграмма (Subburts)\n\n\n\n\n\n\n\n\n\n\n\n2.44.3 Круговая диаграмма (Pie chart)\n\n\n\n\n\n\n\n\n\n\n\n2.44.4 Линейная диаграмма (Line graph, Line plot)\n\n\n\n\n\n\n\n\n\n\n\n2.44.5 Гистограмма (Histogram)\n\n\n\n\n\n\n\n\n\n\n\n2.44.6 График плотности распределения (Density plot)\n\n\n\n\n\n\n\n\n\n\n\n2.44.7 Dot plot\n\n\n\n\n\n\n\n\n\n\n\n2.44.8 Ящик с усами (Boxplot)\n\n\n\n\n\n\n\n\n\n\n\n2.44.9 Violin plot\n\n\n\n\n\n\n\n\n\n\n\n2.44.10 График интервальных оценок (Error bar)\n\n\n\n\n\n\n\n\n\n\n\n2.44.11 Диаграмма рассенияния (Scatter plot)\n\n\n\n\n\n\n\n\n\n\n\n2.44.12 Пузырьковая диаграмма (Bubble plot)\n\n\n\n\n\n\n\n\n\n\n\n2.44.13 Корреляционная матрица (Corrplot)\n\n\nRows: 495 Columns: 133\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (11): id, oth_text, expoth_text, sex, edulvl1, spec1, edulvl2, spec2, j...\ndbl (122): e_dighelp, n_dighelp, e_socnet, f_socnet, n_socnet, gt_score, pr0...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#good-bad-practices-в-визуализации",
    "href": "l2.html#good-bad-practices-в-визуализации",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.45 Good & Bad practices в визуализации",
    "text": "2.45 Good & Bad practices в визуализации\n\n2.45.1 Хорошо\n\nПодписать оси так, чтобы было понятно, что они обозначают\nИспользовать контрастную палитру цветов (или обойтись черно-белой)\nПроверить, как видят график люди с цветовыми аномалиями зрения\nВыстроить из визуализаций историю\n\n\n\n2.45.2 Плохо\n\nИспользовать разные диапазоны шкал или разный масштаб на графиках, которые необходимо сравнивать\nСтроить столбчатую диаграмму не от нуля\nСтроить визуализацию в 3D на бумаге\nСтроить круговую диаграму\nСтроить круговую диаграмму в 3D\n\nБольше примеров странных визуализаций тут.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#философия-a-layered-grammar-of-graphics",
    "href": "l2.html#философия-a-layered-grammar-of-graphics",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.46 Философия A Layered Grammar of Graphics",
    "text": "2.46 Философия A Layered Grammar of Graphics\n\nГрафик состоит из нескольких независимых друг от друга элементов\n\nосновы графика (фон и оси)\nсистемы координат\nспособов отображения данных (геометрических объектов)\nшкал\nфасетов\n\nОднотипные элементы графика располагаются на отдельных слоях\nВычисления отделены от визуализации\nДизайн отделен от содержания\n\nЭти принципы легли в основу пакета ggplot2.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l2.html#итоги",
    "href": "l2.html#итоги",
    "title": "2  L2 // Предобработка данных. Дата и время Визуализация данных",
    "section": "2.47 Итоги",
    "text": "2.47 Итоги\n\nФорматы файлов данных бывают разные и их нужно по-разному загружать в R\nRStudio Projects — это хорошо и помогает воспроизводимости\nПредобработка данных — это определенный набор операций, которые в tidyverse достаточно интуитивно реализованы\nСтроки и даты требуют к себе особого внимания\nВизуализаций много, они разнообразны и каждая по-своему хороша",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>L2 // Предобработка данных. Дата и время Визуализация данных</span>"
    ]
  },
  {
    "objectID": "l3.html#дискретная-математика",
    "href": "l3.html#дискретная-математика",
    "title": "3  L3 // Математика для анализа данных",
    "section": "3.1 Дискретная математика",
    "text": "3.1 Дискретная математика\n\n3.1.1 Алгебра логики\nЛогика исследует закономерности мышления, но делает это отлично от того, как этим занимается, например, психология. Формальная логика абстрагируется от связей мышления с какими-либо сторонами сознания и сосредотачивается на логической непротиворечивости и последовательности мышления. Таким образом, формальная логика — это наука об общих структурах правильного мышления в его языковой форме (Зегет (1985)).\nЛогика — это нормативная наука, то есть она определяет, как оно должно быть, в то время как, например, психология исследуется как оно есть и как и почему логические законы нарушаются.\n\n3.1.1.1 Высказывания\nЛогика как наука имеет дело, прежде всего, с высказываваниями. Высказывание отражает определённую объективную1 связь между предметами. Высказывание истинно, если в нём содержится адеквантное отражение этой связи — в ином случае высказывание ложно. В общем случае высказывание существует с форме повествовательного предложения.\nНапример, высказывание «Земля вращается вокруг Солнца» отражает объективное отношение, поэтому оно истинно, а высказывание «страницы этой книги зелёного цвета» не адекватно отражает существующее положение дел, поэтому оно ложно.\nПрежде всего, нас будут интересовать атомарные высказывания. Это элементарные высказывания, которые невозможно разделить на составляющие — более мелкие высказывания. Например, «четыре — это целое число» — это атомарное высказывание.\nАтомарные высказывания могут быть либо истинны, либо ложны. Почему? Потому что мы находимся в рамках двузначной логики2. Атомарные высказывания могут быть обозначены пропозициональными переменными. Так же как и числа в математике могут быть заменены буквеными обозначениями для абстрагирования от значения числа, так же и высказывания заменяются переменными для абстрагирования от содержания высказывания.\nДля обозначения пропозициональных переменных используются латинские буквы. А так как само высказывания имеет опредлённое значение истинности (истина и ложь), то и переменная, которой мы обозначаем это высказывание, также будет обладать этим же значением истинности. Всё аналогично математике.\n\n\n3.1.1.2 Логические операции\nС атомарными высказываниями можно выполнять различные логические операции.\n\n3.1.1.2.1 Инверсия\nСамая простая операция — инверсия, или отрицание. Оно обозначается с помощью оператора \\(\\neg\\). Это унарная операция, то есть она применяется к одной переменной. При отрицании значение истинности высказывания изменяется на противоположное, поэтому мы можнм составить следующую таблицу истинности для отрицания:\n\n\n\n\\(p\\)\n\\(\\neg p\\)\n\n\n\n\nистина\nложь\n\n\nложь\nистина\n\n\n\nВ данном случае с помощью переменной \\(p\\) обозначено некоторые атомарное высказывание.\nОсобо стоит отметить, что при отрицании отрицается всё высказывание целиком, а не какой-то отдельный его элемент. То есть формально правильным вариантом отрицания высказывания «все лебеди белые» будет следующий — «неверно, что все лебеди белые».\nГрафически инверсия отображается так:\n\n\n\n\nЛогическое отрицание\n\n\n\n\nИз атомарных высказываний можно составлять сложные высказывания при помощи логических операторов. Например, высказывание «если четыре делится на два, то четыре — чётное число» является сложным, посколько состоит из двух атомарных — «четыре делится на два» и «четыре — чётное число» — соединённых союзом «если…, то…».\nДалее мы пристумаем с знакомству с бинарными операторами, то есть такими, которые функционируют на двух аргументах.\n\n\n3.1.1.2.2 Конъюнкция\nКонъюнкция (логическое умножение, логические И) представляет собой такое высказывание, которое наиболее точно передается следующей конструкцией естественного языка — «как \\(p\\), так и \\(q\\)».\n\\(p\\) и \\(q\\) в данном случае пропозициональные переменные, которые заменяют конкретные высказывания. Конъюнкция истинна тогда и только тогда, когда обе пропозициональные переменные, входящие в её состав, имеют значении истинности «истина». В любом ином случае конъюнкция ложна.\nКонъюнкция обозначается символом \\(\\wedge\\) и имеет следующую таблицу истинности:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\wedge q\\)\n\n\n\n\nистина\nистина\nистина\n\n\nистина\nложь\nложь\n\n\nложь\nистина\nложь\n\n\nложь\nложь\nложь\n\n\n\nГрафически конъюнкция отображается так:\n\n\n\n\nКонъюнкция (логическое И)\n\n\n\n\n\n3.1.1.2.3 Дизъюнкция\nДизъюнкция (логическое сложение, логические ИЛИ) представляет собой такое высказывание, которое наиболее точно передается следующей конструкцией естественного языка — «или \\(p\\), или \\(q\\), или и то и другое», поэтому дизъюнкция истинна тогда, когда хотя бы одна пропозициональная переменная, входящая в её состав, имеет значении истинности «истина». В случае, если оба высказывания ложны, дизъюнкция будет ложна.\nДизъюнкция обозначается символом \\(\\vee\\) и имеет следующую таблицу истинности:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\vee q\\)\n\n\n\n\nистина\nистина\nистина\n\n\nистина\nложь\nистина\n\n\nложь\nистина\nистина\n\n\nложь\nложь\nложь\n\n\n\nГрафически дизъюнкция отображается так:\n\n\n\n\nДизъюнкция (логическое ИЛИ)\n\n\n\n\n\n3.1.1.2.4 Разделительная дизъюнкция\nРазделительная дизъюнкция (исключающее ИЛИ) — это такое высказывание, которое наиболее полно описывается следующим выражением естественного языка — «либо \\(p\\), либо \\(q\\)». На её графическом представлении хорошо видно, чем она отличается от обычной дизъюнкции — она исключает ту часть пространства, где верны оба высказывания:\n\n\n\n\nРазделительная дизъюнкция (исключающее ИЛИ)\n\n\n\nДля обозначения разделительно дизъюнкции есть много различных операторов, но мы будем записывать её так — \\(p \\,\\text{XOR}\\,q\\). По иллюстрации можно восстановить таблицу истинности для этого оператора:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\,\\text{XOR}\\,q\\)\n\n\n\n\nистина\nистина\nложь\n\n\nистина\nложь\nистина\n\n\nложь\nистина\nистина\n\n\nложь\nложь\nложь\n\n\n\nТаким образом, видно, что исключающее ИЛИ истинно тогда, когда значения истинности пропозициональных переменных, входящих в сложное высказывание, различны.\n\n\n\n3.1.1.3 Условные высказывания\n\n3.1.1.3.1 Импликация\nСложное высказывание, описываемое конструкцией естественного языка «если \\(p\\), то \\(q\\)» в формальной логике носит название импликации. Она отражает следование одного утверждения из другого и обозначается следующим образом — \\(p \\rightarrow q\\). Высказывание \\(p\\) называется антецедентом имликации, а \\(q\\) — консеквентом импликации.\nИмпликация имеет следующую таблицу истиности:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\rightarrow q\\)\n\n\n\n\nистина\nистина\nистина\n\n\nистина\nложь\nложь\n\n\nложь\nистина\nистина\n\n\nложь\nложь\nистина\n\n\n\nКак видно из таблицы, импликация ложна только тогда, когда её антецедент истинен, и консеквент — ложен. Но что более интересно, так это то, что, согласно таблице, из ложного утверждения может следовать любое. Это факт мы вспомним, когда будем обсуждать тестирование статистических гипотез.\nИмпликацию утвержает то же самое, что и следующее сложное высказывание — \\(\\neg (p \\wedge \\neg q)\\). Отсюда можно получить графическое изображение импликации:\n\n\n\n\nИмпликация \\(p \\rightarrow q\\)\n\n\n\n\n\n3.1.1.3.2 Репликация\nРепликация похожа на импликацию, но действует как бы в обратном направлении, что отражено в её обозначении — \\(p \\leftarrow q\\). Эта конструкция читается как «\\(p\\) реплицирует \\(q\\)» и является эквивалентом естественноязыкового «только если \\(p\\), то \\(q\\)». Соответствующим образом изменяется и таблица истиности:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\leftarrow q\\)\n\n\n\n\nистина\nистина\nистина\n\n\nистина\nложь\nистина\n\n\nложь\nистина\nложь\n\n\nложь\nложь\nистина\n\n\n\nИдея здесь в том, что если мы получили в результате истину, то лжи в начале быть не могло. Графическое изображение репликации выглядит так:\n\n\n\n\nРепликация \\(p \\leftarrow q\\)\n\n\n\n\n\n3.1.1.3.3 Эквиваленция\nЕсли мы соединим с помощью конъюнкции импликацию и репликацию, то есть запишем вот такое высказывание — \\((p \\rightarrow q) \\wedge (p \\leftarrow q)\\) — то получим эквиваленцию. По своей сути она является логическим отражением языковой конструкции «\\(q\\) только тогда, когда \\(p\\)», поэтому она обозначается вот так — \\(p \\leftrightarrow q\\) — и её таблица истинности выглядит соответствующим образом:\n\n\n\n\\(p\\)\n\\(q\\)\n\\(p \\leftrightarrow q\\)\n\n\n\n\nистина\nистина\nистина\n\n\nистина\nложь\nложь\n\n\nложь\nистина\nложь\n\n\nложь\nложь\nистина\n\n\n\nИз неё выводится графическое представление эквиваленции:\n\n\n\n\nЭквиваленция \\(p \\leftrightarrow q\\)\n\n\n\n\n\n\n\n3.1.2 Элементы теории множеств\nНа базе теории множеств стоит вся современная математика. Мы ознакомимся только c некоторыми концепциями этого раздела математики, но вообще полезно с ним познакомиться гораздо глубже.\n\n3.1.2.1 Множество\nПонятие множества неопределимо. По крайней мере силами самой теории множеств. Но мы будем понимать под множеством совокупность, или набор, некоторых (в общем случае любых) объектов. Это могут быть числа, буквы, точки и любые другие объекты. Объекты, входящие в состав множества, называются элементами этого множества.\nМножества обозначают заглавными латинскими буквами (например, \\(A\\)), а его элементs — прописными латинскими буквами (например, \\(a_1\\), \\(a_2\\) и т.д.).\nМножества удобно изображать кружочками. Примерно так:\n\n\n\n\nМножество \\(А\\), содержащее элементы \\(a_1\\), \\(a_2\\), \\(a_3\\), \\(a_4\\), \\(a_5\\)\n\n\n\nЕсли элемент входит в данное множество, то мы говорим, что этот элемент принадлежит данному множеству, и записываем это следующим образом:\n\\[ a_i \\in A \\]\nСимвол \\(\\in\\) читается как «принадлежит».\nЕсли мы хотим задать множество через перечисление элементов, то можно это сделать с помощью фигурных скобок вот так:\n\\[ B = \\{ 0,1,2,3,4,5 \\} \\]\nВ данном случае множество \\(B\\) содержит 6 элементов — числа от нуля до пяти.\nПриведём примеры множеств.\n\nМножество букв русского алфавита: \\(L = \\{ а, б, в, г, д, \\dots, э, ю, я \\}\\)\nМножество всех натуральных чисел4: \\(\\mathbb{N}= \\{ 0, 1, 2, 3, \\dots \\}\\)\nМножество всех целых чисел: \\(\\mathbb{Z}= \\{0, 1, -1, 2, -2, 3, -3, \\dots \\}\\)\n\nТакже из числовых множеств мы можем вспомнить рациональные числа \\(\\mathbb{Q}\\), действительные (вещественные) числа \\(\\mathbb{R}\\) и комплексные числа \\(\\mathbb{C}\\).\nМы можем взять и рассмотреть не все элементы какого-то множества, а какую-то их часть. Например, взять элементы \\(a_1\\) и \\(a_2\\) и объединить их в множество поменьше.\n\n\n\n\nМножество \\(А_1\\), состоящее из элементов \\(a_1\\) и \\(a_2\\), является подмножеством множества \\(A\\)\n\n\n\nМы получим множество \\(A_1 = \\{a_1, a_2\\}\\), которое является подмножеством множества \\(A\\). Иначе говоря, множество \\(A_1\\) включается во множество \\(A\\):\n\\[\nA_1 \\subset A\n\\]\nВ частности, множество натуральных чисел включается во множество целых \\(\\mathbb{N}\\subset \\mathbb{Z}\\). А если продолжить эту цепочку, то можно получить следующую иерархию числовых множеств:\n\\[\n\\mathbb{N}\\subset \\mathbb{Z}\\subset \\mathbb{Q}\\subset \\mathbb{R}\\subset \\mathbb{C}\n\\]\nТривиальными подмножествами любого множества является пустое множество \\(\\varnothing\\) и само это множество. Пусть \\(M\\) — любое множество. Тогда можно записать два справедливых утверждения:\n\\[\n\\varnothing \\subset M\n\\]\n\\[\nM \\subset M\n\\]\n\n\n3.1.2.2 Операции над множествами\n\n3.1.2.2.1 Объединение\nНад множествами можно производить определённые операции. Во-первых, множества можно складывать, или объединять:\n\\[\nA + B = A \\cup B = \\{ x : x \\in A \\vee x \\in B \\}\n\\]\nТогда в новом множестве окажутся все элементы обоих исходных множеств.\n\n\n\n\nОбъединение множеств \\(A\\) и \\(B\\)\n\n\n\n\n\n3.1.2.2.2 Пересечение\nВо-вторых, множества можно умножать, или находить их пересечение:\n\\[\nA \\cdot B = A \\cap B = \\{ x : x \\in A \\wedge x \\in B \\}\n\\]\nТогда в новом множестве окажутся те элементы, которые принадлежат обоим множествам сразу.\n\n\n\n\nПересечение множеств \\(A\\) и \\(B\\)\n\n\n\n\n\n3.1.2.2.3 Разность множеств\nВ-третьих, можно искать разность множеств:\n\\[\nA ∖ B = \\{ x : x \\in A \\wedge x \\notin B \\}\n\\]\n\n\n\n\nРазность множеств \\(A\\) и \\(B\\)\n\n\n\nВ частности, если мы будем искать разность между универсумом \\(U\\) — множеством, которое содержит вообще все возможные элементы — и множеством \\(A\\), мы получим дополнение множества \\(A\\):\n\\[\nU ∖ A = A^c = \\bar A = \\{ x : x \\notin A \\}\n\\]\n\n\n\n\nДополнение множества \\(A\\)\n\n\n\n\n\n3.1.2.2.4 Симметрическая разность\nА ещё можно вычитать множества друг из друга, то есть искать их симметрическую разность:\n\\[\nA \\, \\Delta \\, B = ( A ∖ B ) \\cup ( B ∖ A ) = \\{ x : x \\in A \\text{XOR} \\x \\in B \\}\n\\]\n\n\n\n\nСимметрическая разность множеств \\(A\\) и \\(B\\)\n\n\n\n\n\n3.1.2.2.5 Декартово произведение\nНу, и самое красивое — декартово произведение двух множеств. Пусть у нас есть два множества \\(A\\) и \\(B\\). Тогда их декартово произведение представляет собой множество всех возможных упорядоченных пар \\((a,b), a \\in A, b \\in B\\).\n\\[\nA \\times B = \\{ (a,b) : a \\in A, b \\in B \\}\n\\]\n\n\n\n\nДекартово произведение множеств \\(A\\) и \\(B\\)\n\n\n\nУпорядоченность подразумевает, что если мы будем перемножать \\(A \\times B\\), то будут получаться пары \\((a,b)\\), а если \\(B \\times A\\), то пары \\((b,a)\\).\nК слову, вспомните координатную плоскость — это ни что иное, как декартово произведение двух координатных прямых: \\(\\mathbb{R}\\times \\mathbb{R}= \\mathbb{R}^2 = \\{ (x, y) : x \\in \\mathbb{R}, y \\in \\mathbb{R}\\}\\).\n\n\n\n3.1.2.3 Отображения\nМы можем сопоставлять элементы много множества элементам другого. Тогда мы получим отображение. Например, мы можем взять множество букв латинского алфавита и сопоставить каждому элменту этого множества число, которое будет отображать позицию буквы в алфавите. Пусть у нас есть множество букв латинского алфавита \\(L\\):\n\\[\nL = \\{ \\text{a}, \\text{b}, \\text{c}, \\text{d},\\dots, \\text{x}, \\text{y}, \\text{z} \\}\n\\]\nи множество натуральных чисел от 1 до 26 \\(N\\):\n\\[\nN = \\{ 1,2,3, \\dots,24,25,26 \\}\n\\]\nТогда мы можем задать такое отображение \\(F\\)\n\\[\nF : L \\rightarrow N,\n\\]\nгде каждой букве будет соответствовать её порядковый номер в алфавите.\nМы обозначили отображение буквой \\(F\\), которой в математике часто обозначают функции — это не случайно. Не вдаваясь в детали, можно сказать, что термины «отображение» и «функция» — синонимы. Ведь по сути что делает [математическая] функция? Сопоставляет между собой значения числовых множеств. То есть отображает одно числовое множество в другое.\nНапример, простая функция \\(y = x\\), \\(x \\in \\mathbb{R}\\), \\(y \\in \\mathbb{R}\\) отображает множество вещественных чисел в само себя — \\(F : \\mathbb{R}\\rightarrow \\mathbb{R}\\). Функция модуля \\(y = |x|\\) отображает множество вещественных чисел во множество положительных вещественных чисел — \\(F : \\mathbb{R}\\rightarrow \\mathbb{R}_{+}\\). И так далее.\nВ случае с буквами мы могли бы задать функцию \\(f(l) = n\\), \\(l \\in L\\), \\(n \\in N\\) которая возвращала бы следующие результаты:\n\\[\nf(\\text{a}) = 1, \\quad f(\\text{b}) = 2, \\quad f(\\text{z}) = 26\n\\]\n\n\n\n\nОтображение \\(F : L \\rightarrow N\\)\n\n\n\n\n\n3.1.2.4 Мощность множества\nМножества могут содержать разное количество элементов. Характеристика, описывающая, сколько элементов содержит данное множество, называется мощностью множества.\nВо-первых, множества могут быть конечными и бесконечными.\n\nЕсли множество конечно, то его мощность равна количеству его элементов.\n\nНапример, множество очков, которое может выпать на стандартном игральном кубике — это \\(S_1 = \\{1,2,3,4,5,6\\}\\). Его мощность равна 6 — \\(|M| = 6\\).\nМножество значений пятибалльной шкалы Ликерта — это \\(S_2 = \\{1, 2, 3, 4, 5\\}\\). Его мощность равна 5 — \\(|S_2| = 5\\).\n\nЕсли множество бесконечно, то надо понять, насколько оно бесконечно.\n\nБесконечности бывают разного размера. В детали мы погружать не будем, однако отметим, что есть два вида бесконечностей.\n\nЕсли можно построить отображение, в котором каждом элементу некоторого множества \\(S\\) будет сопоставлено единственное натуральное число3, то такое множество называется счётным.\n\nЭто значит, что элементов во множестве \\(S\\) бесконечное количество — так как количество натуральных чисел бесконечно — однако при неограниченном количестве времени их все-таки можно пересчитать.\nМощность такого множетсва обозначается \\(\\aleph_0\\), то есть \\(|\\mathbb{N}| = \\aleph_0\\).\n\nЕсли количество элементов множества больше количества натуральных чисел, то такое множество обладает **мощностью континуума* \\(\\aleph_1\\).\n\nЭто множество будет равномощно множеству вещественных чисел \\(\\mathbb{R}\\).\n\n\nВозможно, это звучит весьма контринтуитивно — как одна бесконечность может быть больше другой? — однако это так: вещественных чисел больше, чем натуральных.\n\n\n\n3.1.3 Элементы комбинаторики\n\n3.1.3.1 Перестановки\nПредставим такую задачу: на черной пятнице мы накупили книг по анализу данных, и нам необходимо расставить их на полке. Всего у нас есть пять книг. Сколькими способами мы это сможем сделать?\nПодойдём к вопросу технически: возьмем и начнём расставлять. На первое место мы можем поставить любую из пяти книг, то есть вариантов заполнить первое место на полке — пять штук. Когда первое место заполнено, то вариантов заполнить второе место остаётся четыре. Всего возможных вариантов заполнения первых двух мест получается \\(5 \\times 4\\).\nЗаполняем далее: на третье место претендуют три оставшиеся книги, то есть вариантов, которыми мы можем расставить три книги — \\(5 \\times 4 \\times 3\\).\nСледуя далее этой логике мы получим, что всего возможных вариантов расставить все пять книг на полке будет\n\\[\n5 \\times 4 \\times 3 \\times 2 \\times 1 = 5!\n\\]\nМы получили формулу числа перестановок из \\(n\\) элементов:\n\\[\nP_n = n!\n\\]\nТо есть любые \\(n\\) объектов можно расставить на \\(n\\) мест \\(n!\\) способами.\n\n\n3.1.3.2 Размещения\n\n3.1.3.2.1 Без повторений\nТеперь представим, что у нас очень маленькая полка, и на ней умещается всего три книги. Сколькими способами мы можем заполнить такую полку, если всего в нашем распоряжении пять книг?\nВсего перестановок из пяти книг \\(5!\\), однако в силу того, что на полку умещаются только три первые книги из каждой перестановки, отличных друг от друга вариантов теперь будет меньше. Во сколько раз? В число раз, равно количеству перестановок из тех книг, которые на полку не помещаются. В нашем случае — \\((5 - 3)!\\).\nТо есть мы можем заполнить нашу полку \\(\\dfrac{5!}{(5-3)!}\\) способами.\nМы получили формулу для подсчета числа размещений (без повторений) из \\(n\\) элементов по \\(k\\) местам:\n\\[\nA_n^k = \\frac{n!}{(n-k)!}\n\\]\n\n\n3.1.3.2.2 С повторениями\nКаждой книги у нас по одному экземпляру, поэтому выше мы говорили о размещениях без повторений. Для полноты картины посмотрим на размещения с повторениями, хотя они встречаются в практике реже.\nТеперь у нас неограниченное количество копий каждой из книг, поэтому при размещении трех из пяти книг на полке все три могут оказаться одной и той же, или две одинаковые, а одна отличается и т.д. Суть — книги могут повторяться.\nПоскольку теперь, независимо от того, сколько книг мы уже поставили, у нас все равно осталось столько же, то есть 5 — ведь есть копии, каждый раз мы будем выбирать из пяти книг. Таких выборов нам нужно будет сделать три, так как три места на полке. Итого, заполнить нашу полку мы сможем \\(5^3\\) способами.\nМы получили формулу для подсчета числа размещений с повторениями из \\(n\\) элементов по \\(k\\) местам:\n\\[\n\\overline{A_n^k} = n^k\n\\]\n\n\n\n3.1.3.3 Сочетания\n\n3.1.3.3.1 Без повторений\nА теперь задача такова: нам не важно в каком порядке будут стоять книги на полке — нам нужно просто поставить три какие-то книги. Сколько возможно вариантов выбрать три книги из пяти?\nТак как мы теперь не учитываем порядок книг, то возможных вариантов будет в \\(3!\\) раз меньше, чем число размещений. Почему? Так как все перестановки этих трёх книг для нас теперь идентичны. Итого, всего вариантов выбрать три книги из пяти \\(\\dfrac{5!}{3!(5-3)!}\\).\nМы получили формулу для подсчета числа сочетаний из \\(n\\) элементов по \\(k\\):\n\\[\nС_n^k = \\frac{n!}{k!(n-k)!}\n\\]\nПоследняя формула на пригодится далее при обсуждении схемы испытаний Бернулли.\n\n\n3.1.3.3.2 С повторениями\nВновь для полноты картины посмотрим на случай с повторениями. У нас вновь есть неограниченное количество копий каждой книги, однако порядок выставления на полку нам не важен — как и было в сочетаниях. Количество сочетаний в этом случае будет равно\n\\[\n\\overline{С_n^k} = \\frac{(n+k-1)!}{k!(n-1)!}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>L3 // Математика для анализа данных</span>"
    ]
  },
  {
    "objectID": "l3.html#элементы-математического-анализа",
    "href": "l3.html#элементы-математического-анализа",
    "title": "3  L3 // Математика для анализа данных",
    "section": "3.2 Элементы математического анализа",
    "text": "3.2 Элементы математического анализа\nИз всего матана нам надо уловить два основных концепта — производную и интеграл. Эти и займёмся, захватив попутно немного пределов.\n\n3.2.1 Последовательности\nЧисловая последовательность — это последовательность чисел [внезапно]. В общем случае — любых. Она обозначается \\((x_n)^\\infty_{n=1}\\), где \\(x_n\\) — это некоторый элемент последовательности, а верхний и нижний индексы обозначают границы изменения индекса n. Например, \\(\\langle 1,-1,1,-1,\\dots \\rangle\\) — это числовая последовательность, которую можно обозначить \\(\\big( (-1)^n \\big)^\\infty_{n=1}\\).\nПоследовательность возникает на некотором множестве чисел. Если на таком множестве определено отношение порядка, то есть элементы этого множества можно сравнивать на «больше-меньше-равно», то можно сформировать монотонную последовательность. Это такая последовательность, которая не возрастает — то есть стоит на месте или убывает — или не убывает — то есть стоит на месте или возрастает. Более того, если существует такой объект (число), к которому элементы последовательности приближаются с ростом номер, то он является…\n\n\n3.2.2 Предел последовательности\n…пределом этой последовательности.\nРазберемся на примере. Пусть у нас есть вот такая простенькая последовательность:\n\\[\n\\Big( \\frac{1}{n} \\Big)^{\\infty}_{n=1} = \\Big \\langle 1, \\frac{1}{2}, \\frac{1}{3}, \\dots \\Big \\rangle\n\\]\nДостаточно очевидно, что каждый следующий её элемент, меньше предыдущего. Отрицательными элементы данной последовательности быть не могут, поэтому кажется, что всё идет к тому, что где-то там последовательность упрётся в ноль.\nФормально число \\(a\\) называется пределом последовательности \\(\\{x_n\\}\\), если для любого положительного числа \\(\\varepsilon\\) существует номер \\(N_\\varepsilon\\), такой что для любого \\(n &gt; N_\\varepsilon\\), выполняется равенство \\(|x_n - a| &lt; \\varepsilon\\), или на математическом:\n\\[\n\\lim_{n \\rightarrow \\infty} x_n = a \\Leftrightarrow \\forall \\varepsilon &gt; 0 \\exists N_\\varepsilon \\in \\mathbb{N}: n \\geq N_\\varepsilon, |x_n - a| &lt; \\varepsilon\n\\]\nТо есть, в случае нашей последовательности мы можем отсутупить на сколь угодно малое число \\(\\varepsilon\\) от нуля, и, начиная с какого-то номера, все элементы нашей последовательности окажутся в интервале \\((\\varepsilon, 0)\\). Поэтому \\(\\lim_{n \\rightarrow 0} \\frac{1}{n} = 0\\).\n\n\n3.2.3 Функции\nФункции (они же отображения, как мы выяснили выше) устанавливают соответствие между элементами двух множеств. Чаще всего мы имеет дело с числовыми функциями, то есть такими, которые ставят одни числа в соответствие другим. У любой функции есть область определения (множество \\(X\\)) и область значений (множество \\(Y\\)). Сама же функция представляет собой множество упорядоченных пар\n\\[\n(x,y) \\in X \\times Y,\n\\] таких что\n\nпары существуют для всех элементов \\(X\\), и\nесли первые элементы пар равны, то равны и их вторые элементы.\n\nПримерами функций могут быть \\(y = x^2\\), \\(y = kx + b\\), \\(y = |x|\\) и другие.\n\n\n\n\n\nПримеры функций\n\n\n\n\n\n3.2.3.1 Дискретные и непрерывные функции\nВ зависимости от того, какова область определение функции, то есть множество \\(X\\), функции могут быть дискретными и непрерывными. Например, если функция определена на множестве целых чисел \\(\\mathbb{Z}\\), то она будет дискретная, так как между, например, \\(1\\) и \\(2\\) будет пусто.\n\n\n\n\n\nПример графика дискретной функции\n\n\n\n\nЕсли функция определена на множестве \\(\\mathbb{R}\\), то она будет непрерывной. Например, функция \\(f(x) = x^2\\) является непрерывной, как ифункции \\(f(x) = \\sqrt{x}\\) и \\(f(x) = \\ln(x)\\). Если функция непрерывная, то она дифференцируема4.\n\n\n\n3.2.4 Производная\nА раз они дифференцируемы, то мы можем взять производную!\nПроизводная — очень полезная вещь. Во-первых, она показывает тангенс угла наклона касательной в данной точке, а во-вторых скорость и направление изменения функции в данной точке. На самом деле, и первое, и второе рассказывает нам примерно об одном и том же.\nДавайте издалека. Как нам узнать, куда двигается функция в данной точке?\nПусть дана функция \\(f(x) = 2x^3 + 3x^2-4x+6\\).\n\n\n\n\n\n\n\n\n\nВыберем точку \\(x_0\\), в которой мы хотим определить, куда и с какой скоростью движется наша функция. В этой точке функция имеет значение \\(y_0\\):\n\n\n\n\n\n\n\n\n\nШагнём на некоторую дистанцию \\(\\Delta x\\) вправо (по направлению оси \\(x\\)). Назовём эту дистанцию приращением аргумента. В точке \\(x_0 + \\Delta x\\) фунция будет иметь какое-то значение \\(y_0 + \\Delta y\\), где \\(\\Delta y\\) — приращение функции.\n\n\n\n\n\n\n\n\n\nНаша функция движется из точки \\((x_0,y_0)\\) в точку \\((x_0 + \\Delta x, y_0 + \\Delta y)\\). Имеем следующий треугольник — приблизим картинку:\n\n\n\n\n\n\n\n\n\nНас интересует угол \\(alpha\\) — именно он задает скорость и направление изменения функции. Если мы узнаем, каков угол \\(\\alpha\\) — а точнее \\(\\tan \\alpha\\), потому что так проще — то узнаем, куда движется функция.\n\\[\n\\tan \\alpha = \\frac{\\Delta y}{\\Delta x}\n\\]\nНу, хорошо. Но мы шагали достаточно далеко от точки, которая нас интесует. Если мы будем постепенно уменьшать шаг, то получим последовательность\n\\[\n\\langle \\tan \\alpha_1, \\tan \\alpha_2, \\tan \\alpha_3, ... \\rangle\n\\]\nУ этой последовательности есть предел, и если мы его рассчитаем, то как раз и получим значение производной в данной точке.\n\\[\nf'(x_0) = \\lim_{\\Delta x \\rightarrow 0} \\frac{\\Delta f_(x)}{\\Delta x} = \\frac{df}{dx}(x_0)\n\\]\nОчень маленькое приращение обозначается \\(dx\\) (или \\(df\\) , если это приращение функции). Вот мы и получили производную.\nМожно построить график производной. Это тоже будет функция.\nВажное свойство этой функции, которое нам понадобится в дальнейшем, заключается в том, что там, где график производной пересекает ось \\(x\\) — то есть там, где производная равна нулю — на исходной функции случаются точки смены монотонности — точки минимума и максимума.\n\n\n\n\n\n\n\n\n\nПроизводные основных элементарных функций можно найти тут.\n\n\n3.2.5 Частная производная\nМы хорошо знакомы с функциями одной переменной, где некий \\(y\\) зависит от некоего \\(x\\) и более ни от чего не зависит. Однако в общем случае никто нам не может помешать задать следующую функцию:\n\\[\nf(x, y) = 2x^2 + y^3\n\\]\nТеперь у нас две переменные — \\(x\\) и \\(y\\) — и от них обоих зависит значение функции. Это даже можно изобразить:\n\n\n\n\n\n\nВ общем-то наличие второй переменной практически ничего не меняет, однако появляется важная фича — мы можем смотреть, как изменяются значения функции при изменении каждой переменной в отдельности. Это позволяют делать частные производные.\nЧастные производные в целом беруться так же, как и обычные, только мы предполагаем, что все другие переменные — то есть те, по которым мы не берём производную в данный момент — это константы. Таким образом, мы как бы фиксируем другие переменные и получаем скорость изменения функции по какой-либо одной переменной.\nРассмотрим на примере нашей функции \\(f(x, y) = 2x^2 + y^3\\). Пусть мы хотим взять производную по \\(x\\). Тогда мы предполагаем следующее:\n\\[\ny = \\text{const}\\Rightarrow y^3 = \\text{const}= c\n\\]\nФцнкция примет следующий вид:\n\\[\nf(x, y) = 2x^2 + c,\n\\]\nа производная по \\(x\\) будет вычисляться следующим образом:\n\\[\n\\frac{\\partial f(x, y)}{\\partial x} = (2x^2 + c)' = (2x^2)' = 4x\n\\]\n\\(\\frac{\\partial f(x, y)}{\\partial x}\\) — это обозначение частной производной, аналогично тому, как мы обозначали производную через \\(\\frac{dy}{dx}\\).\nАналогично можно найти частную производную по \\(y\\):\n\\[\nx = \\text{const}\\Rightarrow 2x^2 = \\text{const}= c\n\\]\n\\[\n\\frac{\\partial f(x, y)}{\\partial y} = (c + y^3)' = (y^3)' = 3x^2\n\\]\nЗнакомство с вычислением частной производной понадобится нам, чтобы понять, как внутри устроена линейная регрессия и ухватить идею градиентного спуска.\n\n\n3.2.6 Интеграл\nИнтеграл — штука мощная, но нам он понадобится только с одной стороны. Нам надо будет искать площадь под кривой. Этим и займемся.\nПусть у нас есть функция \\(y = \\sqrt{x}\\). Нам надо найти площадь под её графиком на отрезке от \\(0\\) до \\(3\\).\n\n\n\n\n\n\n\n\n\nМы можем разбить этот отрезок на части размером \\(\\Delta x\\), а саму площадь на соответствующие прямоугольники. Это нам позволит оценить площадь. На рисунке ниже \\(\\Delta x = 0.25\\).\n\n\n\n\n\n\n\n\n\nПолучается, площадь можно оценить, сложив площади всех прямоугольников:\n\\[\nS \\approx \\sum_{i=1}^n y_i \\Delta x\n\\]\nЯсно, что чем более узкими прямоугольники у нас будут, тем точнее мы будем знать площадь. Ниже представлены рисунки для случая \\(\\Delta x = 0.1\\) и \\(\\Delta x = 0.05\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЧтобы вычислить площадт точно, снова воспользуемся пределами, и определим с их помощью определенный интеграл:\n\\[\n\\lim_{\\Delta x \\rightarrow 0} \\sum_{i = 1}^n y_i \\Delta x = \\int_a^b \\sqrt{x}\\,dx\n\\]\nОпределенный он потому, что мы знаем, площадь в каких границах нас интересует. Определённый интеграл — это число.\n\\[\n\\int_0^3 \\sqrt{x} \\, dx \\approx 3.46\n\\]\nА раз есть определённый интеграл, значит есть и неопределённый. Рассмотрим следующую визуализацию:\n\n\n\n\nПостроение неопределенного интеграла\n\n\n\nМы смотрим, как изменяется площадь под графиком некоторой функции \\(f(x)\\) по мере нашего движения по оси \\(x\\) (нижний график), и строим график, по оси \\(y\\) которого расположена площадь под исходным графиком, левее данного \\(x\\). Этот график и отображает неопределенный интеграл, второе название которого первообразная. Неопределённый интеграл (первообразная) — это такая функция \\(F(x)\\), производная которой \\(F'(x)\\) равняется \\(f(x)\\), то есть исходной функции. Таким образом, справедливо равенство\n\\[\nF'(x) = f(x)\n\\]\nА также справедливо соответствие между определённым и неопредленным интегралом:\n\\[\n\\int_a^b f(x) dx = F(b) - F(a)\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>L3 // Математика для анализа данных</span>"
    ]
  },
  {
    "objectID": "l3.html#элементы-линейной-алгебры",
    "href": "l3.html#элементы-линейной-алгебры",
    "title": "3  L3 // Математика для анализа данных",
    "section": "3.3 Элементы линейной алгебры",
    "text": "3.3 Элементы линейной алгебры\n\n«Увы, невозможно объяснить, что такое матрица. Ты должен увидеть это сам.» Морфеус (Матрица, 1999)\n\n\n3.3.1 Системы линейных уравнений\nЛинейная алгебра занимается решением систем линейных уравнений. Да в общем-то и все. В самом общем виде система линейных уравнений выглядит так:\n\\[\n\\cases{\na_{11}x_1 + a_{12}x_2 + \\cdots + a_{1m}x_m = b_1 \\\\\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2m}x_m = b_2 \\\\\n\\cdots \\\\\na_{n1}x_1 + a_{n2}x_2 + \\cdots + a_{nm}x_m = b_n \\\\\n}\n\\]\nВ данном случае это система из \\(n\\) уравнений с \\(m\\) неизвесными. Хотя такая запись математически предельно верна, выглядит она достаточно громоздко, и ею весьма трудно пользоваться. Поэтому обычно системы линейных уравнений записывают в матричном виде:\n\\[\n\\mathbf{A}\\mathbf{x} = \\mathbf{b}\n\\]\nСогласитесь, читать такое значительно проще. Здесь \\(\\mathbf{A}\\) — это матрица коэффициентов системы, \\(\\mathbf{x}\\) — вектор неизвестных, а \\(\\mathbf{b}\\) — вектор свободных членов системы. Внутри они устроены вот так:\n\\[\n\\mathbf{A} = \\pmatrix{\na_{11} & a_{12} & \\cdots & a_{1m} \\\\\na_{21} & a_{22} & \\cdots & a_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nm}\n}\n\\quad\n\\mathbf{x} = \\pmatrix{x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_m}\n\\quad\n\\mathbf{b} = \\pmatrix{b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_n}\n\\]\nРазберемся с этими структурами подробнее.\n\n\n3.3.2 Векторы\nКак мы уже знаем, вектор — это набор чисел. В зависимости от того, как он расположен, он может быть вектором-строкой (\\(\\mathbf{r}\\)) или вектором-столбцом (\\(\\mathbf{c}\\)):\n\\[\n\\mathbf{r} = \\pmatrix{r_1 & r_2 & r_3 & \\dots & r_n}\n\\] \\[\n\\mathbf{c} = \\pmatrix{c_1 \\\\ c_2 \\\\ c_3 \\\\ \\vdots \\\\ c_m}\n\\]\nГеометрически элементы вектора (числа) являются его координатами в некотором \\(n\\)-мерном пространстве. О переходе от вектора как направленного отрезка к вектору как набору чисел мы говорили в первой лекции.\nПосмотрим, что можно делать с векторами на примере векторов \\(\\mathbf{v}\\) и \\(\\mathbf{w}\\), в которых есть по \\(n\\) элементов.\n\\[\n\\mathbf{v} = \\pmatrix{v_1 & v_2 & v_3 & \\dots & v_n}\n\\]\n\\[\n\\mathbf{w} = \\pmatrix{w_1 & w_2 & w_3 & \\dots & w_n}\n\\]\n\n3.3.2.1 Сложение векторов\nВекторы одинакоых размерностей можно складывать друг с другом:\n\\[\n\\mathbf{v} + \\mathbf{w} = \\pmatrix{v_1 + w_1 & v_2 + w_2 & v_3 + w_3 & \\dots & v_n + w_n}\n\\]\n\n\n3.3.2.2 Умножение вектора на число\nВектор можно умножать на произвольное вещественное число:\n\\[\n\\alpha \\cdot \\mathbf{v} = \\pmatrix{\\alpha \\cdot v_1 & \\alpha \\cdot v_2 & \\alpha \\cdot v_3 & \\dots & \\alpha \\cdot v_n}, \\quad \\forall \\alpha \\in \\mathbb{R}\n\\]\n\n\n3.3.2.3 Скалярное произведение векторов\nВекторы одинаковых размерностей можно скаларярно умножить друг с другом. Скаларное произведение векторов определено как сумма произведений их соответствующих координат:\n\\[\n\\mathbf{v} \\cdot \\mathbf{w} = v_1 w_1 + v_2 w_2 + v_3 w_3 + \\dots + v_n w_n\n\\]\nТаким образом, в результате скалярного произведения векторов получается одно число.\n\n\n\n3.3.3 Матрицы\nКак мы уже знаем, матрица — это двумерный массив чисел. Своего рода табличка. Соответственно, в матрице есть строки и столбцы. Это значит, что одну и ту же матрицу можно записать по-разному. Например, матрицу \\(\\mathbf{A}\\), с которой мы встречались выше, можно записать:\n\nуказав все элементы:\n\n\\[\n\\mathbf{A} = \\pmatrix{\na_{11} & a_{12} & \\cdots & a_{1m} \\\\\na_{21} & a_{22} & \\cdots & a_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nm}\n}\n\\]\n\nзадав её через векторы-столбцы:\n\n\\[\n\\mathbf{A} = \\pmatrix{\n\\mathbf{a_1} & \\mathbf{a_2} & \\cdots & \\mathbf{a_m} \\\\\n}\n\\]\n\nзадав её через векторы-строки:\n\n\\[\n\\mathbf{A} = \\pmatrix{\n\\mathbf{a_1} \\\\ \\mathbf{a_2} \\\\ \\cdots \\\\ \\mathbf{a_n}\n}\n\\]\nВсе три способа записи обозначают один и тот же объек и используются в зависимости от того, какой способ рассмотрения матрицы в данный момен удобнее.\nМатрица характеризуется, прежде всего, размером. В размере сначала указывается количество строк, затем — количество столбцов. Рассматриваемая нами матрица \\(\\mathbf{A}\\) имеет размер \\(n \\times m\\), что можно записать как \\(\\mathbf{A}_{n \\times m}\\).\n\nЕсли количество строк и столбцов в матрице совпадает, она называется квадратной.\nВ матрице есть главная диагональ — слева сверху вправо вниз — и побочная диагональ — справа сверху влево вниз.\nКвадратная матрица, все элементы которой, кроме стоящий на главной диагонали, равны нулю, называется диагональной матрицей.\nЕсть две замечательные матрицы: единичная \\(\\mathbf{I}\\) (или \\(\\mathbf{E}\\)) и нулевая \\(\\mathbf{O}\\).\n\n\\[\n\\mathbf{I} = \\mathbf{E} = \\pmatrix{\n1 & 0 & \\dots & 0 \\\\\n0 & 1 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\dots & 1 \\\\\n}\n\\quad\n\\mathbf{O} = \\pmatrix{\n0 & 0 & \\dots & 0 \\\\\n0 & 0 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\dots & 0 \\\\\n}\n\\]\n\n3.3.3.1 Сложение матриц\nДве матрицы одинакового размера можно складывать друг с другом:\n\\[\n\\mathbf{A}_{n \\times m} + \\mathbf{B}_{n \\times m} = \\pmatrix {\na_{11} + b_{11} & a_{12} + b_{12} & \\dots & a_{1m} + b_{1m} \\\\\na_{21} + b_{21} & a_{22} + b_{22} & \\dots & a_{2m} + b_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} + b_{n1} & a_{n2} + b_{n2} & \\dots & a_{nm} + b_{nm} \\\\\n}\n\\]\nСвойства сложения матриц:\n\nКоммутативность: \\(\\mathbf{A} + \\mathbf{B} = \\mathbf{B} + \\mathbf{A}\\)\nАссоциативность: \\((\\mathbf{A} + \\mathbf{B}) + \\mathbf{C} = \\mathbf{A} + (\\mathbf{B} + \\mathbf{C})\\)\nСуществование нулевого элемента: \\(\\mathbf{A} + \\mathbf{O} = \\mathbf{A}\\)\nСуществование противоположного элемента: \\(\\mathbf{A} + (-\\mathbf{A}) = \\mathbf{O}\\)\n\n\n\n3.3.3.2 Умножение матрицы на число\nЛюбую матрицу можно умножить на вещественное число:\n\\[\n\\alpha \\cdot \\mathbf{A} = \\pmatrix{\n\\alpha \\cdot a_{11} & \\alpha \\cdot a_{12} & \\alpha \\cdot \\cdots & a_{1m} \\\\\n\\alpha \\cdot a_{21} & \\alpha \\cdot a_{22} & \\cdots & \\alpha \\cdot a_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\alpha \\cdot a_{n1} & \\alpha \\cdot a_{n2} & \\cdots & \\alpha \\cdot a_{nm}\n} \\quad \\forall \\alpha \\in \\mathbb{R}\n\\]\n\n\n3.3.3.3 Матричное умножение\nШтош, приступим.\n\nМатрицы можно матрично перемножить друг с другом, если у них совпадают внутренние размерности.\nРезультатом перемножения \\(\\mathbf{A}_{n \\times k} \\times \\mathbf{B}_{k \\times m}\\) является матрица \\(\\mathbf{C}_{n \\times m}\\).\nЭлемент \\(c_{ij}\\) матрицы \\(\\mathbf{C}\\) равен скалярному произведению \\(i\\)-го вектора-строки матрицы \\(\\mathbf{A}\\) и \\(j\\)-го вектора-столбца матрицы \\(\\mathbf{B}\\).\n\nВизуально:\n\n\n\n\nПринцип матричного умножения\n\n\n\nТеперь попробуем это расписать. Пусть есть две матрицы \\(\\mathbf{A}_{n \\times k} \\times \\mathbf{B}_{k \\times m}\\), которые выглядят следующим образом:\n\\[\n\\mathbf{A} =\n\\pmatrix{\\mathbf{a}_1 \\\\ \\mathbf{a}_2 \\\\ \\vdots \\\\ \\mathbf{a}_n} =\n\\pmatrix{\na_{11} & a_{12} & \\dots & a_{1k} \\\\\na_{21} & a_{22} & \\dots & a_{2k} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\dots & a_{nk}\n}\n\\]\n\\[\n\\mathbf{B} =\n\\pmatrix{\\mathbf{b}_1 & \\mathbf{b}_2 & \\dots & \\mathbf{b}_n} =\n\\pmatrix{\nb_{11} & b_{12} & \\dots & b_{1m} \\\\\nb_{21} & b_{22} & \\dots & b_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nb_{k1} & b_{k2} & \\dots & b_{km}\n}\n\\]\n\\[\n\\mathbf{A} \\times \\mathbf{B} = \\pmatrix{\n\\mathbf{a}_1 \\cdot \\mathbf{b}_1 & \\mathbf{a}_1 \\cdot \\mathbf{b}_2 & \\dots & \\mathbf{a}_1 \\cdot \\mathbf{b}_m \\\\\n\\mathbf{a}_2 \\cdot \\mathbf{b}_1 & \\mathbf{a}_2 \\cdot \\mathbf{b}_2 & \\dots & \\mathbf{a}_2 \\cdot \\mathbf{b}_m \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\mathbf{a}_n \\cdot \\mathbf{b}_1 & \\mathbf{a}_n \\cdot \\mathbf{b}_2 & \\dots & \\mathbf{a}_n \\cdot \\mathbf{b}_m \\\\\n} =\n\\]\n\\[\n= \\pmatrix{\n(a_{11}b_{11} + a_{12}b_{21} + \\dots + a_{1k}b_{k1}) & (a_{11}b_{12} + a_{12}b_{22} + \\dots + a_{1k}b_{k2}) & \\dots & (a_{11}b_{1m} + a_{12}b_{2m} + \\dots + a_{1k}b_{km}) \\\\\n(a_{21}b_{11} + a_{22}b_{21} + \\dots + a_{2k}b_{k1}) & (a_{21}b_{12} + a_{12}b_{22} + \\dots + a_{2k}b_{k2}) & \\dots & (a_{21}b_{1m} + a_{22}b_{2m} + \\dots + a_{2k}b_{km}) \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n(a_{n1}b_{11} + a_{n2}b_{21} + \\dots + a_{nk}b_{k1}) & (a_{n1}b_{12} + a_{n2}b_{22} + \\dots + a_{nk}b_{k2}) & \\dots & (a_{n1}b_{1m} + a_{n2}b_{2m} + \\dots + a_{nk}b_{km}) \\\\\n} =\n\\]\n\\[\n= \\pmatrix{\nc_{11} & c_{12} & \\dots & c_{1m} \\\\\nc_{21} & c_{22} & \\dots & c_{2m} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nc_{n1} & c_{n2} & \\dots & c_{nm}\n} = \\mathbf{C}\n\\]\n\\[\nc_{ij} = \\sum_{t=1}^k a_{it}b_{tj}\n\\]\nСвойства матричного умножения:\n\nАссоциативность: \\(\\mathbf{A}(\\mathbf{B}\\mathbf{C}) = (\\mathbf{A}\\mathbf{B})\\mathbf{C}\\) и \\(\\alpha(\\mathbf{A}\\mathbf{B}) = (\\alpha\\mathbf{A})\\mathbf{B} = \\mathbf{A}(\\alpha\\mathbf{B})\\)\nДистрибутивность: \\(\\mathbf{A}(\\mathbf{B} + \\mathbf{C}) = \\mathbf{A}\\mathbf{B} + \\mathbf{B}\\mathbf{C}\\) и \\((\\mathbf{A} + \\mathbf{B})\\mathbf{C} = \\mathbf{A}\\mathbf{C} + \\mathbf{B}\\mathbf{C}\\)\nОтсутствие коммутативности: в общем случае \\(\\mathbf{A}\\mathbf{B} \\neq \\mathbf{B}\\mathbf{A}\\)\nУмножение на единичный элемент: \\(\\mathbf{I}\\mathbf{A} = \\mathbf{A}\\), \\(\\mathbf{A}\\mathbf{I} = \\mathbf{A}\\)\nУмножение на нулевой элемент: \\(\\mathbf{O}\\mathbf{A} = \\mathbf{O}\\), \\(\\mathbf{A}\\mathbf{O} = \\mathbf{O}\\)\nУмножение на обратный элемент — выполняется только для некоторых квадратных матриц (см. ниже): \\(\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{A}^{-1}\\mathbf{A} = \\mathbf{I}\\)\n\n\n\n3.3.3.4 Транспонирование матрицы\nЭто очень простая операция — строки и столбы матрицы меняются местами:\n\\[\n\\mathbf{A} =\n\\pmatrix{\\mathbf{a}_1 & \\mathbf{a}_2 & \\dots & \\mathbf{a}_n} =\n\\pmatrix{\na_{11} & a_{12} & \\dots & a_{1k} \\\\\na_{21} & a_{22} & \\dots & a_{2k} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\dots & a_{nk}\n}\n\\]\n\\[\n\\mathbf{A}^T =\n\\pmatrix{\\mathbf{a}_1 \\\\ \\mathbf{a}_2 \\\\ \\vdots \\\\ \\mathbf{a}_n} =\n\\pmatrix{\na_{11} & a_{21} & \\dots & a_{n1} \\\\\na_{12} & a_{22} & \\dots & a_{n2} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{1k} & a_{2k} & \\dots & a_{nk}\n}\n\\]\nЕсли размер исходной матрицы был \\(n \\times k\\), то размер транспонированной матрицы будет \\(k \\times n\\).\n\n\n3.3.3.5 Определитель и обратная матрица\nОпределитель (детерминант) матрицы \\(\\det \\mathbf{A}\\), \\(|\\mathbf{A}|\\), \\(\\Delta A\\) — это величина, которая может быть вычислена и поставлена в соответствие квадратной матрице. Он «определяет» свойства матрицы, в том числе одно из ключевых — её обратимость.\nВычисление детерминанта матрицы в общем случае является достаточно сложной задачей и требует введения дополнительных определений, поэтому ограничимся интерпретацией его значений:\n\nЕсли матрица не является квадратной, то детерминант не определен.\nЕсли детерминант матрицы не равен нулю, то:\n\nсистема линейных уравнений, задаваемая данной матрицей имеет единственное решение\nдля данной матрицы существует обратная матрица, обладающая следующим свойством — \\(\\mathbf{A}\\mathbf{A}^{-1} = \\mathbf{I}\\).\n\nЕсли детерминан матрицы равен нулю, то система линейных уравнений имеет несколько решений.\n\nОдной из причин может быть линейная зависимость между столбцами или строками матрицы — то есть ситуация, при который один из столбцов (одна из строк) линейной выражается через другой (другую).\n\n\n\n\n3.3.3.6 След матрицы\nСлед матрицы — это сумма элементов главной диагонали (квадратной) матрицы.\n\\[\n\\text{tr}(\\mathbf{A}) = \\sum_i a_{ii}\n\\]\n\n\n\n\nЗегет, В. 1985. Элементарная Логика. Москва: Высшая школа.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>L3 // Математика для анализа данных</span>"
    ]
  },
  {
    "objectID": "l4.html#l4_measures",
    "href": "l4.html#l4_measures",
    "title": "4  L4 // Теория измерений",
    "section": "4.1 Измерения",
    "text": "4.1 Измерения\n\n\n\n\n\n\nNote\n\n\n\nЗдесь мы будем говорить об измерениях в социальных науках. Они имеют определенную спефицику по сравнению, скажем, с физическими измерениями.\n\n\nНачнем с наиболее общего определения измерения.\nИзмерение — процедура приписывания определенным психологическим объектам определенных чисел на определенной шкале.\n\nТехнически звучит не сложно.\nНо часто приходится доказывать, что мы реально что-то померили и сделали это адекватно.\n\nТем не менее, такое общее опреление измерения позволяет нам говорить, что измерить мы может всё, что угодно:\n\nрост\nвозраст\nпол\nнациональность\nколичество детей в семье\nрейтинг студентов\nкурс / уровень обучения\nгеографические координаты (долгота и широта)\nтемпература\nдата\nIQ\nнарциссизм / макиавеллизм / психопатия\nвремя реакции\nточность ответов испытуемого в эксперименте\nи т.д.\n\n\n4.1.1 Какие существуют измерения в разных областях психологии?\nПодходы к измерениям можно поделить по отраслям (областям) психологической науки1:\n\nНейронаука и психофизиология\n\nРегистрируются физиологические (= физические) процессы\nПроцессы [как правило] являются реакциями на физическую стимуляцию\nПредполагается, что эти физиологические процессы являются коррелятами некоторых психических процессов\n\\(\\Phi \\rightarrow \\Phi (\\sim \\Psi)\\)\n\nПсихофизика\n\nИзмеряются субъективные феномены (реакции, ощущения, пороги)\nСубъективные реакции происходят на физическую стимуляцию\n\\(\\Psi \\rightarrow \\Phi\\)\n\nПоведенческие исследования\n\nИзмеряются поведенческие реакции с помощью объективных метрик (времени реакции, точности кликов, последовательности поиска)\nПоведенческие реакции [как правило] обусловлены физической стимуляцией\nПредполагается, что за поведенческими реакциями стоят некоторые психические процессы\n\\(B \\rightarrow \\Psi\\)\n\nПсихометрика\n\nИзмеряются субъективные феномены, не связанные напрямую с физиологическим процессами\nЧасто (= всегда) изучаются гипотетические конструкты\nИзмерение происходит с помощью субъективных методик\n\\(\\Psi \\rightarrow \\Psi\\)\n\n\nИз подобного методологического безобразия происходят две важных мысли:\n\nВ любой области психологической науки нам необходимо с теоретических позиций обосновать связь измеряемых в ходе исследования переменных с изучаемыми психическими феноменами.\nПри любом измерении нам необходимо выбрать адекватный способ числового отражения изучаемых феноменов, чтобы мы могли использовать статистические методы анализа.\n\nТаким образом, если мы уточним в свете последней важной мысли определение измерения, то оно будет звучать так:\nИзмерение — это процедура приписывания психологическим объектам чисел таким образом, чтобы отношения между числами соответствовали отношениям между психологическими объектами2.\nДействительно, с числами можно делать всё, что угодно, что не запрещено математикой — а не запрещено ею много чего, однако не любые математические операции имеют смысл по отношению к исходными психологическим объектам. Из этих ограничений возникают шкалы.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>L4 // Теория измерений</span>"
    ]
  },
  {
    "objectID": "l4.html#l4_scales",
    "href": "l4.html#l4_scales",
    "title": "4  L4 // Теория измерений",
    "section": "4.2 Шкалы",
    "text": "4.2 Шкалы\nМожно найти много технических определений шкалы, одно из которых звучит весьма красиво:\n\nШкала — это числовая структура, изоморфная эмпирической структуре.\n\nНо такое определение мало что проясняет относительно содержания шкалы. Для нас удобнее будет менее точное, но более осязаемое понимание:\n\nШкала — это набор чисел с органичениями на допустимые по отношению к ним операции.\n\nВ таком понимании ещё С. Стивенсом в 1946 году были предложены четыре вида шкал — это классификацией мы пользуемся до сих пор:\n\nНоминальная шкала (шкала наименований, nominal scale)\nПорядковая шкала (ранговая шкала, ordinal scale)\nИнтервальная шкала (шкала разностей, interval scale)\nАбсолютная шкала (шкала отношений, ratio scale)\n\nШкалы отличаются друг от друга по математическому содержанию используемых на них чисел, допустимым на них математическим (и логическим) операциям и преобразованиям, наличию и характеру нуля, типу шкалы и типу данных.\n\n4.2.1 Признаки и переменные\nВ ходе исследования мы измеряем различные признаки изучаемых объектов. Попытаемся эти признаки как-то систематизировать. В терминах данных признаки — это переменные, поэтому далее мы будем чаще употребляться именно этот термин — переменная — имея в виду то, что мы намерили, изучая интересующий нас признак изучаемого объекта. Во многом признак и переменная — это синонимы, только первый термин больше из теории измерений, а второй из статистики и анализа данных. Измерение же от отдельного человека / объекта выборки называется наблюдение. В общем-то с этим мы уже сталкивались, когда обсуждали данные.\nИтак, типы переменных:\n\nКоличественные переменные — те, которые принимают числовые значения. Они могут быть:\n\nнепрерывными — принимают любые значения (рост, возраст, время реакции и др.)\nдискретными — могут принимать только определенные значения (количество детей в семье, число отчисленных студентов, количество пачек гречи, которое человек скупил на карантине и др.)\n\n\nЧисло, приписываемое количественному признаку (переменной) ведёт себя как привычное нам математическое число в том смысле, что выражает некоторое количество — сантиметров, лет, секунд, детей, студентов, пачек гречи…\n\nНоминальные (категориальные) переменные — используются для разделения наших наблюдений на группы (пол, национальность, курс обучения, используемая операционная ситема компьютера и др.)\n\nЗаписаны эти переменные обычно текстом (скажем, пол — male и female или операционная система — Win, MacOS, Linux). Однако, например, курс обучения можно записать по-разному: текстом — freshman, sophomore, junior, senior — и числом — 1, 2, 3, 4. Однако в данном случае цифры не несут никакого математического смысла — это просто лейблы, с помощью которых мы различаем группы наблюдений. Ведь и пол мы можем записать с помощью чисел — пусть male = 0, female = 1. Ведь не будем же мы складывать-вычитать девушек и парней?\nВнимательный читатель мог заметить, что курс обучения это не совсем категориальная переменная, ведь «второкурсник» в каком-то смысле «больше», чем «первокурсник». Но мы не можем сказать «на сколько» или «во сколько» больше! Что же делать?\n\nНельзя сказать, что «второкурсник» выражает большую выраженность признака «год обучения», чем «первокурсник».\nВместе с тем «второкурсник» дольше учился и освоил больше дисциплин, чем «первокурсник». При этом «третькурсник» учился дольше «второкурсника». То есть есть порядок категорий.\nТакая переменная называется ранговой.\n\nДругой пример рагновой переменной — это студенческий рейтинг. Что делает рейтинг? Упорядочивает студентов. Можно ли сказать, что четвертый в рейтинге студент в два раза менее успешен, чем второй? Нет — тот же GPA может отличаться на десятые или сотые доли.\nИтого, переменные:\n\nколичественные\n\nнепрерывные\nдискретные\n\nранговые\nноминальные\n\n\n4.2.1.1 Виды шкал\nОт того, в какой шкале измерена переменная, которую мы исследуем, будет зависеть:\n\nкакие графики мы сможем нарисовать\nкакие статистики на ней имеют смысл\nкакие статистические модели дадут адекватный результат\n\nВ общем, почти весь анализ определяется тем, с какой шкалой мы работаем, поэтому разберем каждую шкалу подробнее.\n\n\n4.2.1.2 Номинальная шкала\n\nНаименее мощная шкала\nНеметрическая — расстояния между делениями не определены\nТип данных — категориальные\nДопустимые операции\n\nсравнение на (не)равенство\n\nНоль — отсутствует\nДопустимые преобразования — любое, сохраняющее взаимно однозначное соответствие\n\nВ этой шкале, что весьма ожидаемо, измеряются номинальные переменные. Даже если на этой шкале используются числа для задания категорий, они не несут никакого математического смысла, что следует из допустимых операций данной шкалы.\nСтоит отдельно оговорить, что значит преобразование, сохраняющее взаимно однозначное соответствие. Пусть у нас есть самая типичная социально-демографическая номинальная переменная исследований — пол. И пусть он у нас закодирован как male и female. Мы можем преобразовать эту переменную как угодно. Единственное условие, которое у нас есть — это возможность опознать мужчин и женщин по присвоенным лейблам. Так, мы можем использовать числа 1 и 0 или 618 и 1040, задать текстовые лейблы m и f или м и ж, или даже выдумать что-то ещё типа gfbc и rtsu. Последний вариант технически совершенно не удобен, но устройства шкалы его вполне допускает, так как сохранено взаимно-однозначное соответствие между реальным объектами и используемыми лейблами.\n\n\n4.2.1.3 Порядковая шкала\n\nНеметрическая — расстояния между делениями не равны между собой\nТип данных — категориальные / ранговые\nДопустимые операции\n\nсравнение на (не)равенство\nсравнение на больше-меньше\n\nНоль — отсутствует\nДопустимые преобразования — любое монотонное\n\nНа этой шкале появляется порядок значений, а значит и операция сравнения на больше-меньше. Нет делений — вернее, даже если есть, то они разного размера — поэтому складывать и вычитать ещё нельзя.\nПреобразование на этой шкале должно сохранять порядок её значений, так как этой ключевая характеристика данной шкалы. Так, в принципе мы можем извлечь квадратный корень из переменной уровень обучения (бакалавриат, специалитет, магистратура, аспирантура), которая закодирована как 1, 2, 3, 4 — получится 1, 1.4, 1.7, 2. Это нам усложнит жизнь, несомненно, однако шкалу не сломает — порядок элементов сохранен.\n\n\n\n\n\n\nО термине «качественные данные».\n\n\n\nПочему-то номинальную и ранговую шкалы в литературе часто называют «качественными». Видимо, потому что качественные данные обычно рассматриваются как оппозиция количественным.\nЭто в некоторой мере справедливо, поскольку есть два типа исследований — качественные и количественные. Они различаются методологией и используемыми методиками и, как следствие, собираемыми данными.\nВ рамках качественных исследований чаще всего собираются тексты, поэтому во многом качественные данные по факту обычно текстовые. Количественные данные — это, как правило, таблицы с цифрами из любой из четырёх шкал. Безусловно, анализ качественных и количественных данных тажке существенно различается.\nИтого, кажется, называть «качественными» номинальную и ранговые шкалы — странно, потому что качественные данные — это неструктурированный текст. Лучше их именовать категориальными. Правда, например, рейтинг студентов (ранговая шкала) тоже не совсем категориальные данные… ай, ладно — будут ранговые!\n\n\n\n\n4.2.1.4 Интервальная шкала\n\nМетрическая — расстояния между делениями одинаковые\nТип данных — количественные\nДопустимые операции\n\nсравнение на (не)равенство\nсравнение на больше-меньше\nсложение и вычитание\n\nНоль — относительный\nДопустимые преобразования — любое линейное\n\nНа этой шкале появляется возможность складывать и вычитать, так как есть точка отсчета — ноль — и деления становятся одинакового размера. Правда выбран этот ноль случайно, поэтому он не отражает полное отсутствие признака у изучаемого объекта. По этой причине операции умножения и деления на этой шкале невозможны.\nКоличество возможных преобразований также сокращается — теперь при преобразовании шкалы нам важно сохранить равенство интервалов. Этому требованию соответствуют линейные преобразования, так как они выполняют условия линейности:\n\\[\nf(x+y) = f(x) + f(y)\n\\] \\[\nf(\\alpha x) = \\alpha f(x)\n\\]\nТак, квадратный корень из значений шкалы извлечь уже не получится, потому что равенство интервалов нарушится.\n\n\n4.2.1.5 Абсолютная шкала\n\nСамая мощная шкала\nМетрическая — расстояния между делениями одинаковые\nТип данных — количественные\nДопустимые операции\n\nсравнение на (не)равенство\nсравнение на больше-меньше\nсложение и вычитание\nумножение и деление\n\nНоль — абсолютный\nДопустимые преобразования — любое преобразование подобия\n\nНаличие абсолютного нуля на данной шкале позволяет производить с её значениями все математические операции. Однако это же существенно ограничивает набор допустимых преобразований — теперь нам важно сохранять этот самый абсолютный ноль, поэтому невозможно прибавить или вычесть какие-либо число из всех значений шкалы (сдвинуть её вправо или влево, вверх или вниз). Получается, можно только умножить или разделить шкалу на некоторое значение, что и является преобразованием подобия.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>L4 // Теория измерений</span>"
    ]
  },
  {
    "objectID": "l4.html#психометрические-измерения",
    "href": "l4.html#психометрические-измерения",
    "title": "4  L4 // Теория измерений",
    "section": "4.3 Психометрические измерения",
    "text": "4.3 Психометрические измерения\nВыше мы уже выяснили, что психометрические измерения особо выделяются среди всех других измерений в психологических науках. Еще раз обозначим, почему:\n\nИзмеряются ненаблюдаемые (латентные) конструкты с помощью субъективных шкал\n\nне знаем достоверно, существуют ли наши конструкты\n\nПоследствия\n\nВ измерениях всегда есть существенная доля ошибки → нужно знать надёжность (точность) измерения\nМы не всегда уверены, действительно ли измерили то, что хотим → нужно обосновать валидность измерения\n\nОдного вопроса обычно недостаточно, чтобы задать содержание конструкта или добиться нужной точности измерения\n\n\n\n\n4.3.1 Операциональная классификация методик\nВстает вопрос, а как мы вообще можем измерять в психометрике что-либо?\nОперациональная классификация распределяет методики в зависимости от того, насколько результат их процедуры зависит от субъективного опыта респондента и самого диагноста.\n\nВыше черты — прямые методы\n\nОтветы респондента используются для интерпретации напрямую и обычно количественно\n\nНиже черты — непрямые методы\n\nОтветы респондента интерпретируются не напрямую и во многом методами качественного анализа\n\n\nПолучается следующая картина:\n\nПриборные психофизиологические методики\nАппаратурные поведенческие методики\nОбъективные тесты с выбором ответа (тесты способностей или тесты знаний)\nТесты-опросники (прямой субъективный самоотчет)\nСубъективное шкалирование\n\n———————————————————————————\n\nПроективные методики\nНаблюдение\nКонтент-анализ\nПсихологическая беседа\nРолевая игра\nОбучающий эксперимент\n\nЗдесь, конечно, методики взяты шире, чем обычно используются в психометрике. Чаще всего, сталкиваясь с психометрикой, мы имеет дело с объективными тестами3 и тестами-опросниками.\nОтдельный вопрос касается тестов-опросников — почему прямой субъективный самоотчет вообще работает? Здесь есть две ключевых идеи:\n\nВновь С. Стивенс нам сказал, что люди могут прямо оценивать интенсивность стимулов, приписывая им числа. Тем самым, он легитимизировал прямой субъективный самоотчет.\nКогда мы говорим об исследовательской работе, мы проводим психометрические измерения и диагностику в ситуации, которая предполагает свободное дальнейшее поведение4, то есть респонденты сами решают, как им обойтись с результатами тестирования — поэтому искажения предполагаются минимальными.\n\n\n\n4.3.2 Психометрика в двух словах\nТак или иначе, мы оказывается в потрясающей ситуации:\n\nизмеряем непонятно что, непонятно чем и непонятно как\n\n\nС одной стороны, кажется, что ситуация довольно безвыходная, однако психометрики придумали множество инструментов, чтобы совладать с подобным стечением объстоятельств. С другой стороны, если вы не занимаетесь психометрикой непосредственно и оказались к ней критически близко в силу необходимости использования психометрических инструментов в собственном исследовании, стоит понимать, что психометрика — это обычная научная область, со своими особенностями, проблемами и кризисами, которая она пытается решать, как и любая другая. И это окей.\n\n\n4.3.3 Концепт. Конструкт. Операционализация\nЧтобы начать конструировать психометрический инструмент, прежде всего необходимо определить, что мы собираемся измерять, поэтому первым шагом является определение измеряемого конструкта.\nКонструкт — это прямым образом ненаблюдаемая переменная, характеризующая различия в поведении людей в специфической группе ситуаций (Messick (1993), Barrett (2005)).\n\nхарактеристика, навык, способность человека, которую мы хотим оценить или измерить\nбазируется на одной или нескольких теориях\nне может быть измерен непосредственно, но с помощью различных индикаторов или переменных\nможет быть простым и сложным\n\nНапример, простыми конструктами будут:\n\nПринадлежность к политической партии\nСтаж\nУмение умножать\nДетский эгоцентризм (по Пиаже)\nЗнание букв\n\nСложными же могут выступить:\n\nУдовлетворенность работой\nМатематическая грамотность\nУчебная мотивация\nКоммуникация\nНавык достижения цели\n\nЗа конструктом может стоять ещё более обобщенная идея, задающая теоретическу рамку, в которой определяется конструкт — концепт.\nКонцепт — это обобщенная идея, разделяемая многими людьми (сообществом), которая может быть представлена в рамках той или иной теории или подхода.\nСуществуют некоторые различия в том, как смотрят на измеряемые конструкты в образовательном и психологическом тестировании:\n\nПсихологическое тестирование\n\nИзмерение какого-либо латентного конструкта\n\nопределение конструкта, основанное на теориях и / или исследованиях\nоперационализация конструкта\nобласти содержания\n\n\nОбразовательное тестирование\n\nОбразовательные результаты (освоение программы, курса, года, и т. д.)\n\nсоответствует ФГОС\nсоответствует учебному плану / программе\nотражает цели обучения\n\n\n\nПосле определения конструкта наступет этап операционализации:\n\nопределение конструкта в терминах операций, необходимых для его измерения (Machery (2007))\nпроцесс и документ, описывающий переход от теоретического, абстрактного понятия к наблюдаемому поведению, измеряемому в тесте\n\nОперационализация подразумевает разработку:\n\nсубконструктов и их взаимосвязей,\nгрупп ситуаций, в которых они проявляются,\nспособов сбора информации об их проявлении (Mislevy, Almond, Lukas (2003), Brennan (2006))\n\n\n\n4.3.4 Тестовые задания. Области содержания конструкта. Структура опросника\nКогда операционализация разработана, наступает этап разработка тестовых заданий. Мы не будем останавливаться здесь на принципах их разработки — это отдельная большая область с массой нюансов и деталей. Остановимся на двух важных вещах.\n\nПри разработке пунктов опросника должны быть учтены области содержания конструкта — ситуации и контексты, в которых он может проявляться\n\nЧем шире конструкт, тем в большем количестве контекстов он может проявляться и тем больше областей содержания должен охватывать опросник\n\nВ структуру психометрического инструмента может входит несколько субшкал или несколько субтестов\n\nЕсли опросник состоит из нескольких субшкал, то его можно использоваться только как единый психометрический инструмент — не допускается использование отдельных субшкал опросника при сборе данных.\nЕсли опросник состоит из нескольких субтестов, то возможно использование отдельных субтестов при сборе данных.\n\n\n\n\n4.3.5 Виды шкал в психометрических инструментах\nВ классификации шкал психометрических инструментов частично дублируется классификация измерительных шкал, однако добавляются и новые основания.\n\nПо характеру отношений\n\nнеметрические (номинальная и порядковая)\nметрические (разностей и отношений)\n\nПо числовому соответствию\n\nдискретные\nнепрерывные (континуальные)\n\nПо наличию и/или смыслу полюсов\n\nбиполярные\nуниполярные\n\nПо материалу\n\nграфические\nтекстовые\nчисловые\n…\n\n\nВид используемой шкалы зависит от целевой аудитории теста (дети, взрослые, клиническая выборка и др.), диагностической ситуации, особенностей измеряемого конструкта, теоретических основания и т.д.\nКлассическая психометрическая шкала — это шкала Ликерта. Она обладает следующими характеристиками:\n\nбиполярная\nзаданы текстом все альтернативы\nравные интервалы [визуально]\nгоризонтальная\nданы целые числа [от 1 до 5]\n\n\n\n4.3.6 Психометрические характеристики шкалы\n\nНадежность — это мера свободы результатов от ошибки измерения (standard error of measurement, SEM).\nНадежность нельзя рассчитать напрямую — можно только аппроксимировать\nРазными методами — ни один из них не является полностью верным\nНо нам приходится с этим как-то жить\n\nМетоды расчета надежности:\n\nCronbach’s \\(\\alpha\\) — надежность-внутренняя согласованность\nМетод расщепленных половин\nРетестовая надежность\n\n\n\n4.3.7 Психометрические характеристики пунктов\n\n4.3.7.1 Трудность задания\n\nДля дихотомического случая\n\n\\[\nb_j = \\frac{s_{1j} \\cdot p_{1j} + s_{2j} \\cdot p_{2j}}{N_j} = \\frac{0 \\cdot p_{1j} + 1 \\cdot p_{2j}}{N_j} = \\frac{p_{2j}}{N_j}\n\\]\n\nДля политомического случая\n\n\\[\nb_j = \\frac{\\sum_{k=1}^{K_j}(s_{kj} \\cdot p_{kj})}{N_j \\cdot s_{Kj}}\n\\]\nИнтерпретация значений трудности:\n\nЧем выше показатель трудности, тем легче справиться с заданием\nСлишком трудные — [0.00, 0.05] — и слишком легкие — [0.95, 1.00] — задания плохо дифференцируют выборку\nНачинать кодировку ответов лучше с 0 — так проще жить и интерпретировать результаты\n\n\n\n4.3.7.2 Дискриминативность задания\n\nТест направлен на измерение некоторого конструкта\nСуммарный тестовый балл отражает выраженность конструкта\nЧем сильнее коррелирует балл по заданию с баллом по тесту, тем лучше задание различает респондентов\nЛучше использовать скорректированную меру — корреляцию балла по заданию с суммой баллов по всем другим заданиям\n\n\n\n\n4.3.8 Валидность\nВалидность — это соответствие результатов тестирования заявленной цели тестирования, в частности, тому психическому свойству (или свойствам), которое измеряется.\n\nВ широком смысле — сведения о поведении и психических явлениях, находящихся в причинной зависимости от диагностируемого свойства.\nАналогично можно говорить о валидности тестового задания.\n\n\nГлавная цель разработки психометрического инструмента — сбор как можно большего количества разных свидетельств валидности.\n\n\n\nСбор разных свидетельств валидности обеспечивает обоснованный вывод о том, что по результатам теста можно выносить соответствующие суждения о тестируемых.\n\n\n\n4.3.8.1 Виды валидности\n\n4.3.8.1.1 Концептуальная валидность\n\nобоснование тестовой методики с позиций соответствия авторским (теоретическим) представлениям об особенностях диагностируемых свойств\nмера соответствия содержания заданий теста авторской концепции этих свойств.\n\n\n\n4.3.8.1.2 Конструктная валидность\n\nопределяет область теоретической структуры психологических явлений, измеряемых тестом\nтест, базирующийся на развитой, логически-связной теории, обеспеченной высоко-операционализированными понятиями, обладает конструктной валидностью\n\nВиды конструктной валидности:\n\nвнутренняя валидность / надежность–внутренняя согласованность\nдифференциальная валидность\nконвергентная валидность\nдискриминантная валидность\n\n\n\n4.3.8.1.3 Внутренняя валидность\n\nподчиненность пунктов (заданий, вопросов) теста основному направлению теста как целого\nориентированность пунктов на изучение одних и тех же конструктов\nанализ осуществляется путем коррелирования ответов на каждое задание с общим результатом теста\nдинамика изучаемого конструкта\n\n\n\n4.3.8.1.4 Дифференциальная валидность\n\nвнутренние взаимоотношения между диагностируемыми факторами\nтесты интересов\n\nобычно умеренного коррелируют с показателем общей академической успеваемости\nно связаны с успеваемостью по отдельным дисциплинам\nособенно важна как показатель диагностической ценности методик в профотборе\n\n\n\n\n4.3.8.1.5 Эмпирическая валидность\n\nсовокупность характеристик валидности теста, полученных экспериментально-статистическим способом\n\nкритериальная\n\nтекущая / диагностическая / конкурентная\nретроспективная\nпрогностическая\n\nконвергентная\nдискриминантная\nконцессуальная\n\n\n\n\n4.3.8.1.6 Конвергентная валидность\n\nстепень соответствия баллов двух тестовых методик, направленных на измерение одного и того же или концептуально-родственных конструктов\nзначимая корреляция между тестами\n\n\n\n4.3.8.1.7 Дискриминантная валидность\n\nстепень, в которой тест не измеряет тот конструкт, для измерения которого он не предназначен\nотсутствие значимой корреляции между тестовыми показателями, отражающими концептуально независимые свойства\nчастный случай — отсутствие корреляции с переменными приводящими к фальсификации или мотивационным искажениям результата\n\nнапример, социальная желательность\n\n\n\n\n4.3.8.1.8 Критериальная валидность\n\nотражает соответствие результатов тестирования определенным значениям критериальной переменной или вероятности критериального события\nнезависимые от результатов теста непосредственные меры исследуемого качества\n\nуровень достижения в чем-либо\nстепень развития способности\nвыраженность определенного свойства личности\nпоказатели социально- или производственно-значимых результатов деятельности\n\n\nТекущая (конкурентная)\n\nкритериальное событие происходит сейчас, в момент исследования\n\nРетроспективная\n\nкритериальное событие уже произошло\n\nПрогностическая\n\nкритериальное событие будет потом\nнужен квазиэксперимент\n\n\n\n4.3.8.1.9 Концессуальная валидность\n\nустановлении связи (корреляции) тестовых данных с данными, полученными от внешних экспертов\nэксперты хорошо знакомы с тестируемыми\n\n\n\n4.3.8.1.10 Очевидная валидность (face validity)\n\nнасколько сам тест и его задания кажутся респондентам подходящими для цели тестирования\nвысокая очевидная валидность присуща также кейс-тестам.\nочень часто не совпадает с научной концепцией валидности\nвысокая очевидная валидность часто является весьма желательной\nфактор, побуждающий респондента к сотрудничеству, серьезному и ответственному отношению к выполнению заданий и к восприятию результатов оценки\n\n\n\n4.3.8.1.11 Содержательная валидность\n\nстепень соответствия содержания заданий теста той реальной деятельности, в которой проявляется измеряемое психическое свойство\n\nучебные тесты, тесты профессиональных достижений\n\nмного разнородных, факторов — личностные особенности, знания, умения и навыки, специальные способности — нужна адекватная модель тестируемой деятельности\n\nподбор заданий, охватывающие главные аспекты изучаемого феномена в правильной пропорции к реальной деятельности в целом\n\nавторское обоснование пригодности теста в самом содержании тестовых заданий\n\n\n\n4.3.8.1.12 Факторная валидность\n\nподтверждения теоретической структуры конструкта, разработанной в ходе операционализации, эмпирическими данными, собранными в ходе количественной апробации методики\nпроводится с помощью [конфирматорного] факторного анализа\n\n\n\n\n\nBarrett, P. 2005. “What If There Were No Psychometrics?: Constructs, Complexity, and Measurement.” Journal of Personality Assessment 85 (2): 134–40.\n\n\nMessick, S. 1993. “Foundations of Validity: Meaning and Consequences in Psychological Assessment.” Ets Research Report Series 1993 (2): i–18.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>L4 // Теория измерений</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Источники",
    "section": "",
    "text": "Barrett, P. 2005. “What If There Were No Psychometrics?:\nConstructs, Complexity, and Measurement.” Journal of\nPersonality Assessment 85 (2): 134–40.\n\n\nMessick, S. 1993. “Foundations of Validity: Meaning and\nConsequences in Psychological Assessment.” Ets Research\nReport Series 1993 (2): i–18.\n\n\nЗегет, В. 1985. Элементарная Логика. Москва: Высшая школа.",
    "crumbs": [
      "Источники"
    ]
  }
]