# L1 // Основы R. Типы и структура данных. Функции и управляющие конструкции

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(latex2exp)
theme_set(theme_bw())
```

## Установка R и RStudio

Чтобы стать счастливым пользователем R, надо установить на свой комп две программы:

- собственно [R](https://cran.r-project.org/)
  + на [Win](https://cran.r-project.org/bin/windows/base/)
  + на [Mac](https://cran.r-project.org/bin/macosx/)
  + на [Linux](https://cran.rstudio.com/bin/linux/)
- IDE [RStudio](https://posit.co/download/rstudio-desktop/)[^r-studio]

[^r-studio]: По пути надо ещё не перепутать с [R-Studio](https://www.r-studio.com/ru/), которая восстанавливает данные с диска. Критическое сходство названий двух программ обязывает к повышенной внимательности при написании работ/статей/отчётов/заявок на гранты, в которых вы ссылаетесь на RStudio --- иногда рецензенты весьма недоумевают, как исследователи анализировали данные с помощью ПО для восстановления данных…

Причем во избежание возможных проблем, надо поставить программы именно в этом порядке --- сначала R, а потом RStudio, иначе IDE может на найти R и будет ругаться.


## R как язык программирования. Команды

В R нет команд и практически нет ключевых слов, распространенных в других языках программирования. Практически все операции обернуты в функции. Остаются только математические и логические операторы, которые, на самом деле, тоже функции.

### Математические операции

Все в наличии:

```{r maths1}
2 + 3 # сложение
4 - 1 # вычитание
5 * 12 # умножение
5 ^ 8 # возведение в степень
4 / 7 # деление
5 %/% 3 # целочисленное деление
5 %% 3 # остаток от деления
```

Скобки также существуют и привычно работают:

```{r maths2}
6 / 3 + 2 * 4
6 / (3 + 2) * 4
6 / ((3 + 2) * 4)
```


### Математические функции

Можно посчитать корень:

```{r funs1}
sqrt(16)
```

Или логарифм:

```{r funs2}
log(10)
log(8, base = 2)
log(8, 2)
```

Или что-то на тригонометрическом:

```{r funs3}
sin(5); cos(5); tan(5)
```

Кстати, можно и вот так --- это к тому, что математические операторы тоже являются функциями:

```{r}
`+`(2, 3)
`^`(4, 5)
`/`(8, 3)
```


### Логические операции

К логическим операциями можно отнести операции сравнения:

```{r logic1}
5 > 4 # больше
6 < 2 # меньше
5 >= 5 # больше или равно
6 <= 3 # меньше или равно
23 == 14 # равно
77 != 98 # не равно
```

А также логические операторы И (`&`) и ИЛИ (`|`):

```{r logic2}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
TRUE | TRUE
TRUE | FALSE
FALSE | FALSE
```


### Переменные и объекты

Результаты вычислений и преобразований хотелось бы сохранять, поэтому в R существует оператор присваивания `<-`:

```{r}
x <- 5
y <- 4 * 8
```

Можно, конечно, написать и `x = 5`, но сообщество вас не поймет и будет косо смотреть... Когда мы присвоим некоторой _переменной_ какой-либо _объект_, он отобразиться в окошке Environment, и с ним можно будет работать. Например, совершать разные операции:

```{r}
x + y
sqrt(x)
log(y, base = x)
```

Объектом в R может быть вообще все, что угодно --- число, строка, вектор, матрица, датафрейм, таблица, результат моделирования, функция и т.д.

## Типы данных

**Тип данных** --- это характеристика данных, которая определяет:

* **множество допустимых значений**, которые могут принимать данные этого типа
* **допустимые операции** над данными этого типа

### `numeric`

Это числа с десятичной частью.

```{r}
class(3.14)
typeof(3.14)
```

`"double"` нам говорит о том, что числа с десятичной частью храняться в R с двойной точностью. И это хорошо.


### `integer`

Это целые числа.

```{r}
class(3)
```

Правда чтобы создать именно целое число, надо указать, что мы хотим именно целое число с помощью литерала `L`:

```{r}
class(3L)
typeof(3L)
```

По умолчанию объект типа `3` воспринимается R как `3.0`, поэтому тип данных будет `numeric`.


### `complex`

Комплексные числа тоже существуют, но я даже не знаю, когда вам придется их использовать.

```{r}
class(2+3i)
```

### `character`

Текст тоже надо как-то хранить.

```{r}
s1 <- 'a'
s2 <- "это строка"

class(s1)
class(s2)
```

Кавычки не важны, если у вас не встречаются кавычки внутри кавычек. Тогда надо использовать разные:

```{r}
s <- 'Мужчина громко зашёл в комнату и высказал решительное "здравствуйте"'
s
```

### `factor`

Бывают такие переменные, которые группируют наши данные. Например,

- город проживания (`Москва`, `Санкт-Петербург`, `Казань`, `Екатеринбург`)
- уровень образования (`бакалавриат`, `специалитет`, `магистратура`, `аспирантура`)
- экспериментальная группа (`group1`, `group2`, `control`)
- и др.

Обычно они текстовые. Для них был придуман тип данных `factor`, чтобы их было дешевле хранить. Однако большинство современных пакетов сами могут решить, когда надо текст перевести в фактор.

`Ordered factor` (**упорядоченный фактор**) --- тип данных, который позволяет задать порядок групп. Например,

- уровень образования: `bachelor` < `master` < `phd` < `postdoc`
- сложность экспериментальной задачи: `easy` < `medium` < `hard`
- и др.

Вот упорядоченный фактор нам время от времени может понадобиться --- например, для создания визуалиация или в некоторых статистических моделях.


### Специальные литералы

#### `NA`

Пропущенное значение (**N**ot **A**vailable). Обозначает отсутствие значения там, где оно вроде бы должно быть. Причины могут быть разные:

- технические ошибки записи данных
- ошибки настройки платформы --- забыли сделать ответы обязательными
- организация исследования --- ограничили время на ответ
- «честный» пропуск --- дали возможность не отвечать на вопрос
- предобработка данных --- специально создали `NA`, чтобы далее с ними работать
- и др.


#### `NaN`

Это не число (**N**ot a **N**umber).

```{r}
0 / 0
```


#### `NULL`

Это ничто. Пустота. Используется для задания аргументов функций.


## Структуры данных


**Структура данных** --- это способ и форма объединения однотипных и/или логически связанных данных.

<center>
<figure>
<img src="pics/tidy-2.jpg">
<figcaption>Пример данных</figcaption>
</figure>
</center>


### Датафрейм

Воплощение привычной нам «таблицы» в R.

```{r, echo=FALSE}
head(ggplot2::diamonds)
```

Это сложная структура данных. Чтобы понять всю её мощь, необходимо начать с более простых.

### Векторы

Вектор --- это набор чисел.

$$
\pmatrix{1 & 4 & 36 & -8 & 90.1 & -14.5}
$$


Если это утверждение вызывает у вас внутренний протест, давай проследим пусть от направленного отрезка в набору чисел.


Возьмем направленный отрезок --- вектор:

```{r vec-classic, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 2, y = 1, xend = 3, yend = 3),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = c(2, 3), y = c(1, 3)), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(2, 1)"), x = 2.5, y = 1) +
  annotate(geom = "text", label = TeX("(3, 3)"), x = 3.5, y = 3) +
  coord_fixed()
```

Именно так мы понимали вектор в школе. Договоримся, что все векторы у нас начинаются из точки $(0, 0)$:

```{r vec-free, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
               arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = 1, y = 2), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.5, y = 2) +
  coord_fixed()
```

Если теперь у нас все вектора начинаются из начал координат, то мы можем полностью описать вектор только координатами его конца. Поэтому уберем вектор:

```{r vec-remove-vector, echo=FALSE}
ggplot(NULL) +
  # geom_segment(aes(x = 0, y = 0, xend = 1, yend = 2),
  #              arrow = arrow(), linewidth = 1) +
  geom_point(aes(x = 1, y = 2), size = 2) +
  xlim(0, 5) + ylim(0, 5) +
  annotate(geom = "text", label = TeX("(1, 2)"), x = 1.5, y = 2) +
  coord_fixed()
```

То есть для нас теперь вектор равносилен точке на плоскости. А точка однозначно описывается двумя координатами. Получается, можно просто записать:

$$
\pmatrix{1 & 2}
$$


Получается, что это одно и то же:

$$
\pmatrix{1 & 0.5}, \quad \pmatrix{2 & 3}, \quad \pmatrix{4.2 & -3.5}
$$

```{r vec-same, echo=FALSE}
ggplot(NULL) +
  geom_segment(aes(x = 0, y = 0, 
                   xend = c(1, 2, 4.2), 
                   yend = c(.5, 3, -3.5)),
               arrow = arrow(), linewidth = 1) +
  xlim(0, 5) + ylim(-5, 5) +
  annotate(geom = "text", label = TeX(c("$(1, 0.5)$", "$(2, 3)$", "$(4.2, -3.5)$")), 
           x = c(1.3, 2.3, 4.5), 
           y = c(.5, 3, -3.5))
```


Теперь обобщим вектор на более общие случаи:

> Вектор --- это набор некоторого колчиества элементов одного типа.

```{r vec-types}
v_num <- c(1, 6, -34, 7.7) # числовой вектор
v_char <- c("Москва", "Санкт-Петербург", "Нижний Новгород", "Пермь") # текстовый вектор
v_log <- c(TRUE, FALSE, TRUE, TRUE) # логический вектор
```

```{r vec-typer-print}
class(v_num)
v_num
class(v_char)
v_char
class(v_log)
v_log
```


#### Индексация векторов

Из вектора можно вытащить его элемент:

```{r}
v_char[2] # по номеру
v_num[v_num > 5] # по условию
```


#### Векторизация

Для того, чтобы выполнить операцию на всем векторе поэлементно, не нужно перебирать его элементы.

```{r}
vec <- 1:4
vec - 1
vec^2
sqrt(vec)
```


#### Recycling

Если мы будем, например, складывать два вектора разной длины, то более короткий зациклится.

```{r}
vec1 <- 1:10
vec2 <- 1:2

vec1
vec2
vec1 + vec2
```



## Матрицы

Если мы желаем приблизиться к датафрейму, то одного ряда элементов нам недостаточно --- надо выходить во второе измерение! Поэтому уложим вектор в матрицу:

<center>
<figure>
<img src="pics/vec-to-mat.png">
<figcaption>Варианты преобразования вектора в матрицу</figcaption>
</figure>
</center>

Или вот еще разные варианты:

```{r}
v <- 1:12
m1 <- matrix(v, nrow = 3)
m1

m2 <- matrix(v, nrow = 4)
m2

m3 <- matrix(v, nrow = 3, byrow = TRUE)
m3

m4 <- matrix(v, nrow = 4, byrow = TRUE)
m4
```


### Индексация матриц

Из матрицы можно вытащить её элементы:

```{r}
m1
m1[2, 3] # отдельный элемент
m1[1, ] # целую строку
m1[, 4] # целый столбец
m1[1:2, 2:4] # часть матрицы
```


## Массивы

- Вектор --- одномерный массив.
- Матрица --- двумерный массив.
- **Массивы** --- структуры, которые объединяют данные только одного типа.

```{r}
c(2, TRUE)
c(2, TRUE, "word")
```

При объединении разных типов данных в одном массиве происходит **приведение типов (coercion)** по следующей иерархии:

<center>
`logical` → `integer` → `numeric` → `complex` → `character`
</center>

Это нам осложняет жизнь, так как мы бы хотели объединять данные разных типов в одну структуру.


## Списки

Списки позволяют объединять массивы различных типов данных, чем делают нашу жизнь значительно приятнее.

<center>
<figure>
<img src="pics/list-structure.png">
<figcaption>Схема внутренней структуры списка</figcaption>
</figure>
</center>

Например, так:

```{r}
l <- list(v1 = v_num,
          v2 = v_char,
          m1 = m1,
          ls = list(v = v,
                    m = m3))
l
```


### Индексация списков

```{r}
l[1] # по номеру элемента, возвращается список
l[[1]] # по номеру элемента, возвращается массив
l$ls # по названию элемента
l$ls$m # можно идти многоуровнево
```


## Собираем датафрейм

- возьмем список
- потребуем, чтобы его элементами были **векторы**
- потребуем, чтобы эти векторы были **одинаковой длины**
- расположим их «вертикально»

<center>
<figure>
<img src="pics/list-vs-df.png">
<figcaption>Структура списка и датафрейма</figcaption>
</figure>
</center>


### Индексация датафрейма

Для примера возьмем датафрейм про бриллианты:

```{r, echo=FALSE}
head(ggplot2::diamonds) -> diam
```

```{r}
diam
```

Датафрейм наследует свойства списка и матрицы, что делает его невероятно гибким в обращении и крайне удобным в работе:

```{r}
diam$carat # вытащить столбец
diam[diam$price > 330, ] # отобрать строки по условию
diam[, c(2:3, 7)] # вытащить столбцы по номерам
diam[1:4, c("carat", "price")] # вытащить отдельные строки по номерам и столбцы по названиям
```


## Функции

> Если какой-либо кусок кода повторяется более трех раз, имеет смысл обернуть его в функцию.

Как стоит понимать функцию?

**Функция** --- это некий черный ящик, который

- принимает что-либо на вход
- проделывает с этим какие-либо операции
- и что-то возвращает

### Синтаксис функции

Синтаксис создания функции выглядит так:

```{r, eval=FALSE}
function_name <- function(arguments) {
    ...
    body
    ...
    return()
}
```

Элементы функции:

- имя функции (`function_name`) --- как мы к ней будем обращаться при вызове
- аргументы функции (`arguments`) --- какие значения и объекты она принимает на вход
- тело функции (`body`) --- что она делает с входными объектами
- возвращаемое значение (`return()`) --- что функция вернет в качестве результата работы

Вызов функции:

```{r, eval=FALSE}
function_name(arguments)
```


### Пример функции

```{r}
cot <- function(x) {
  result <- 1 / tan(x)
  return(result)
}
cot(3)
```


Если функция простая, можно не создавать временные объекты:

```{r}
cot <- function(x) {
  return(1 / tan(x))
}
cot(3)
```

Если функция короткая, можно даже не писать `return()`:

```{r}
cot <- function(x) {
  1 / tan(x)
}
cot(3)
```


### Пример более полезной функции

**Осторожно, большое!**

Это функция, которая занималась предобработкой данных в реальном проекте. Прикиньте, если бы мы такой кусок кода повторяли для каждого датасета... --- жуть!

```{r, eval=FALSE}
mr_preproc <- function(d) {

  require(tidyverse)
  
  d |> select(
    # select columns we need
    "Индивидуальный_код",
    correctAns,
    base_pic,
    rotated_pic,
    resp_MR_easy.keys,
    resp_MR_easy.corr,
    resp_MR_easy.rt
  ) |>
    drop_na() |> # remove technical NAs (recording artefacts, not missing data)
    mutate(task = "MR",
           # add task name (mental rotation)
           level = "easy",
           # add difficulty level
           trial = 1:16) |> # number trials
    rename(
      "id" = "Индивидуальный_код",
      # rename columns for handy usage
      "key" = resp_MR_easy.keys,
      "is_correct" = resp_MR_easy.corr,
      "rt" = resp_MR_easy.rt
    ) -> MR_easy # ready to use
  
  
  d |> select(
    # select columns we need
    "Индивидуальный_код",
    correctAns,
    base_pic,
    rotated_pic,
    resp_MR_medium.keys,
    resp_MR_medium.corr,
    resp_MR_medium.rt
  ) |>
    drop_na() |> # remove technical NAs (recording artefacts, not missing data)
    mutate(task = "MR",
           # add task name (mental rotation)
           level = "medium",
           # add difficulty level
           trial = 1:16) |>  # number trials
    rename(
      # rename columns for handy usage
      "id" = "Индивидуальный_код",
      "key" = resp_MR_medium.keys,
      "is_correct" = resp_MR_medium.corr,
      "rt" = resp_MR_medium.rt
    ) -> MR_medium # ready to use
  
  
  
  d |> select(
    # select columns we need
    "Индивидуальный_код",
    correctAns,
    base_pic,
    rotated_pic,
    resp_MR_hard.keys,
    resp_MR_hard.corr,
    resp_MR_hard.rt
  ) |>
    drop_na() |> # remove technical NAs (recording artefacts, not missing data)
    mutate(task = "MR",
           # add task name (mental rotation)
           level = "hard",
           # add difficulty level
           trial = 1:16) |> # number trials
    rename(
      # rename columns for handy usage
      "id" = "Индивидуальный_код",
      "key" = resp_MR_hard.keys,
      "is_correct" = resp_MR_hard.corr,
      "rt" = resp_MR_hard.rt
    ) -> MR_hard # ready to use
  
  # bind all conditions of mental rotation task to one tibble
  
  bind_rows(MR_easy, MR_medium, MR_hard) -> MR
  
  return(MR)
 
}
```



## Условный оператор

Иногда при написании функции может понадобиться обработать какие-то важные случаи.

- Например, в двух запусках сбора данных столбцы были названы по-разному: если это не учесть, код будет ломаться.

Для этого подойдет условный оператор.

### Структура условного оператора

```{r, eval=FALSE}
if (condition) {
  ...
  body
  ...
} else {
  ...
  body
  ...
}
```


### Пример функции с условным оператором

Допустим, нам жизненно неободима функция, которая будет определять, является число четным или нечетным, потому что сами мы постоянно путаемся...

Вот она:

```{r}
odd_even <- function(x) { # функция принимает на вход число
  
  if (x %% 2 == 0) { # проверяет, равняется ли нулю остаток от деления числа на два
    
    return("even") # возвращает "even", если равняется
    
  } else {
    
    return("odd") # возвращает "odd", если нет
    
  }
  
}

```

```{r}
odd_even(2)
odd_even(34)
odd_even(11)
odd_even(135)
```

Работает!

## Пример функции из реального проекта с условным оператором

```{r}
ms_preproc <- function(d) {
  
  require(tidyverse)
  
  # Since we our participants could fill the fields in any order, 
  # here is a function which allows us to count correct inputs 
  # our subjects made.
  
  if ("mouse_MSe.time" %in% colnames(d)) { 
    ### здесь начинается условный оператор, который проверяет, есть ли такая колонка
    ### если колонка есть, то запускается код ниже
    
    d |> select(
      "Индивидуальный_код",
      matches("^noun"),
      matches("resp\\d\\.text$"),
      "mouse_MSe.time"
    ) |>
      filter_at(vars(paste0("noun", 1:3)), all_vars(!is.na(.))) |>
      filter_at(vars(paste0("noun", 4:7)), all_vars(is.na(.))) |>
      mutate(task = "MS",
             level = "easy") |>
      rename(
        "resp1" = resp1.text,
        "resp2" = resp2.text,
        "resp3" = resp3.text,
        "id" = "Индивидуальный_код",
        "rt" = "mouse_MSe.time"
      ) |>
      select(-c(paste0("noun", 4:7))) -> MS_easy
    
    d |> select(
      "Индивидуальный_код",
      matches("^noun"),
      matches("MSm.text$"),
      "mouse_MSm.time"
    ) |>
      filter_at(vars(paste0("noun", 4:5)), all_vars(!is.na(.))) |>
      filter_at(vars(paste0("noun", 6:7)), all_vars(is.na(.))) |>
      mutate(task = "MS",
             level = "medium") |> 
      rename("id" = "Индивидуальный_код",
             "rt" = "mouse_MSm.time") |>
      rename_with(.fn = str_replace_all, 
                  pattern = "_MSm\\.text", 
                  replacement = "") |> 
      select(-noun6, -noun7) -> MS_medium
    
    
    d |> select(
      "Индивидуальный_код",
      matches("^noun"),
      matches("MSh.text$"),
      "mouse_MSh.time"
    ) |>
      filter_at(vars(paste0("noun", 1:7)), all_vars(!is.na(.))) |>
      mutate(task = "MS",
             level = "hard") |>
      rename("id" = "Индивидуальный_код",
             "rt" = "mouse_MSh.time") |> 
      rename_with(.fn = str_replace_all,
                  pattern = "_MSh\\.text",
                  replacement = "") -> MS_hard
    
  } else {
    ### а если колонки нет, то запускается этот код
    
    d |> select("Индивидуальный_код",
                matches("^noun"),
                matches("resp\\d\\.text$")) |>
      filter_at(vars(paste0("noun", 1:3)), all_vars(!is.na(.))) |>
      filter_at(vars(paste0("noun", 4:7)), all_vars(is.na(.))) |>
      mutate(task = "MS",
             level = "easy",
             rt = NA) |>
      rename(
        "resp1" = resp1.text,
        "resp2" = resp2.text,
        "resp3" = resp3.text,
        "id" = "Индивидуальный_код"
      ) |>
      select(-c(paste0("noun", 4:7))) -> MS_easy
    
    d |> select("Индивидуальный_код",
                matches("^noun"),
                matches("MSm.text$")) |>
      filter_at(vars(paste0("noun", 4:5)), all_vars(!is.na(.))) |>
      filter_at(vars(paste0("noun", 6:7)), all_vars(is.na(.))) |>
      mutate(task = "MS",
             level = "medium",
             rt = NA) |>
      rename("id" = "Индивидуальный_код") |>
      rename_with(.fn = str_replace_all,
                  pattern = "_MSm\\.text",
                  replacement = "") |> 
      select(-noun6, -noun7) -> MS_medium
    
    
    d |> select("Индивидуальный_код",
                matches("^noun"),
                matches("MSh.text$")) |>
      filter_at(vars(paste0("noun", 1:7)), all_vars(!is.na(.))) |>
      mutate(task = "MS",
             level = "hard",
             rt = NA) |>
      rename("id" = "Индивидуальный_код") |> 
      rename_with(.fn = str_replace_all,
                  pattern = "_MSh\\.text", 
                  replacement = "") -> MS_hard
  }
  
  tibble(
    id = MS_easy$id[1],
    trials = 1:16,
    MS_easy_n = n_count(MS_easy),
    MS_easy_rt = MS_easy$rt,
    MS_medium_n = n_count(MS_medium),
    MS_medium_rt = MS_medium$rt,
    MS_hard_n = n_count(MS_hard),
    MS_hard_rt = MS_hard$rt
  ) |>
    pivot_longer(cols = -c("id", "trials"), values_to = "value") |>
    separate(name, c("task", "level", "name")) |>
    pivot_wider(values_from = value, names_from = name) |>
    mutate(acc = ifelse(level == "easy", n / 3,
                        ifelse(
                          level == "medium", n / 5,
                          ifelse(level == "hard", n / 7, NA)
                        ))) -> MS
  
  return(MS)
  
}
```


## Вне функций

Вне функций условный оператор практически не используется, потому что для предобработки данных есть удобная функция `ifelse()`.


## Циклы

То, что мы написали функция, чтобы не дублировать код --- это хорошо, однако эту функцию нам все равно придется запускать много раз, если нам надо этот кусок кода повторить.

Поэтому используем цикл:

```{r, eval=FALSE}
for (i in a:b) {
  ...
  body
  ...
}
```


## Пример простеньких циклов

Просто печатаем числа от 1 до 10:

```{r}
for (i in 1:10) {
  print(i)
}
```

Ну, или более сложные выражения:

```{r}
for (j in 1:10) {
  print(sqrt(j) + j^2)
}
```


## Пример цикла для чтения и предоработки данных

```{r, eval=FALSE}
for (i in 1:length(files)) { ## будем двигаться от 1 до количества файлов в папке с данными
  
  print(files[i]) ## печатает имя файла, чтобы видеть на каком файле сломалось, если сломается
  
  d <- read_csv(files[i], show_col_types = FALSE) ## считывает один файл из папки
  
  ## запускаем функции предобработки
  MR_data |> bind_rows(mr_preproc(d) |> mutate(file = files[i])) -> MR_data
  ST_data |> bind_rows(st_preproc(d) |> mutate(file = files[i])) -> ST_data
  MS_data |> bind_rows(ms_preproc(d) |> mutate(file = files[i])) -> MS_data
  NASATLX_data |> bind_rows(nasatlx_preproc(d) |> mutate(file = files[i])) -> NASATLX_data
  SEQUENCE_data |> bind_rows(sequence_preproc(d) |> mutate(file = files[i])) -> SEQUENCE_data
  
  ## завершили цикл, идем на следующую итерацию

}
```



## Циклы в R --- это зло! Они долго работают!

> Да, циклы работает не быстро --- это правда. Но, с другой стороны, мы и не терабайты данных анализируем.

Допустим, у нас 50 респондентов. Цикл, подобный тому, что на предыдущем слайде, отбработает секунд за 5. Даже чай не успеете заварить.

Безусловно, есть более изящные и быстрые инструменты, и с ними мы познакомимся на предобработке данных. Но в целом, можно и циклом обойтись.

Конечно, если у вас огромные датасеты и вы работаете с Big Data, то прогон цикла может значительно затянуться --- в этом случае разумно сразу использовать другие инструменты.


